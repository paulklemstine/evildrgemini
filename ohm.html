<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phonetic Vocalizer (Prayer Mode)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for sliders */
        input[type=range] {
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            width: 100%; /* Full width */
            height: 8px; /* Specified height */
            background: #555; /* Grey background */
            outline: none; /* Remove outline */
            opacity: 0.7; /* Slightly transparent */
            transition: opacity .2s;
            border-radius: 4px;
        }
        input[type=range]:hover {
            opacity: 1; /* Full opacity on hover */
        }
        /* Thumb styles for Webkit/Blink */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #a855f7; /* Purple thumb */
            cursor: pointer;
            border-radius: 50%;
        }
        /* Thumb styles for Firefox */
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #a855f7; /* Purple thumb */
            cursor: pointer;
            border-radius: 50%;
            border: none; /* Remove default border */
        }
        /* Style for radio buttons */
        .mode-radio-label {
            display: inline-block;
            background-color: #374151; /* Gray-700 */
            color: #d1d5db; /* Gray-300 */
            padding: 6px 12px;
            border-radius: 6px;
            margin: 3px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-size: 0.875rem; /* text-sm */
        }
        .mode-radio-label:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        input[type="radio"]:checked + .mode-radio-label {
            background-color: #a855f7; /* Purple-500 */
            color: #ffffff; /* White */
            font-weight: 600; /* font-semibold */
        }
        input[type="radio"] {
            display: none; /* Hide the actual radio button */
        }
        /* Style for select dropdown */
        select {
            background-color: #374151; /* Gray-700 */
            color: #d1d5db; /* Gray-300 */
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #4b5563; /* Gray-600 */
            margin-top: 4px;
            width: 100%; /* Make select full width */
            font-size: 0.875rem;
        }
        option {
            background-color: #374151;
            color: #d1d5db;
        }
        /* Custom font */
        body {
            font-family: 'Inter', sans-serif; /* Requires loading Inter font if not available system-wide */
        }
        /* Add Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        /* Ensure canvas is behind controls */
        #visualizer { z-index: 0; }
        #controls { z-index: 10; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col md:flex-row min-h-screen overflow-hidden font-sans">

<canvas id="visualizer" class="absolute top-0 left-0 w-full h-full"></canvas>

<div id="controls" class="relative bg-gray-800 bg-opacity-90 backdrop-blur-sm p-4 md:p-6 shadow-xl md:w-1/3 lg:w-1/4 h-screen overflow-y-auto order-1 md:order-2 rounded-lg m-2 md:m-4 border border-gray-700">
    <h1 class="text-xl md:text-2xl font-bold mb-5 text-center text-purple-400">Phonetic Vocalizer</h1>

    <div class="flex justify-around mb-6">
        <button id="startButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-5 rounded-lg shadow-md transition duration-150 ease-in-out flex items-center space-x-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play"><polygon points="5 3 19 12 5 21 5 3"/></svg>
            <span>Start</span>
        </button>
        <button id="stopButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-5 rounded-lg shadow-md transition duration-150 ease-in-out flex items-center space-x-2" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/></svg>
            <span>Stop</span>
        </button>
    </div>
    <div id="status" class="text-center mb-6 text-gray-400 text-sm">Stopped</div>

    <div class="mb-6">
        <label class="block mb-2 font-semibold text-purple-300">Mode:</label>
        <div class="flex flex-wrap justify-center gap-2">
            <input type="radio" name="mode" value="prayer" id="mode_prayer" checked>
            <label for="mode_prayer" class="mode-radio-label">Prayer</label>
            <input type="radio" name="mode" value="chanting" id="mode_chanting">
            <label for="mode_chanting" class="mode-radio-label">Chanting</label>
            <input type="radio" name="mode" value="singing" id="mode_singing">
            <label for="mode_singing" class="mode-radio-label">Singing</label>
            <input type="radio" name="mode" value="ghost" id="mode_ghost">
            <label for="mode_ghost" class="mode-radio-label">Ghost</label>
            <input type="radio" name="mode" value="random" id="mode_random">
            <label for="mode_random" class="mode-radio-label">Random</label>
        </div>
    </div>

    <div id="prayerControls" class="mb-5 space-y-3 p-3 bg-gray-700 bg-opacity-50 rounded-lg border border-gray-600">
        <h3 class="text-sm font-semibold text-purple-200 mb-2 border-b border-gray-600 pb-1">Prayer Settings</h3>
        <div>
            <label for="prayerScale" class="block mb-1 text-xs font-medium text-purple-200">Scale:</label>
            <select id="prayerScale">
                <option value="majorPenta">Major Pentatonic</option>
                <option value="minorPenta">Minor Pentatonic</option>
                <option value="majorScale">Major Scale</option>
                <option value="harmonicMinor">Harmonic Minor</option>
                <option value="mixolydian">Mixolydian Mode</option>
            </select>
        </div>
        <div>
            <label for="wordLength" class="block mb-1 text-xs font-medium text-purple-200">Word Length: <span id="wordLengthValue">4</span> phonemes</label>
            <input type="range" id="wordLength" min="2" max="8" value="4" step="1" class="w-full h-1.5">
        </div>
        <div>
            <label for="phraseLength" class="block mb-1 text-xs font-medium text-purple-200">Phrase Length: <span id="phraseLengthValue">3</span> words</label>
            <input type="range" id="phraseLength" min="1" max="8" value="3" step="1" class="w-full h-1.5">
        </div>
        <div>
            <label for="intonationAmount" class="block mb-1 text-xs font-medium text-purple-200">Intonation Amount: <span id="intonationAmountValue">50</span>%</label>
            <input type="range" id="intonationAmount" min="0" max="100" value="50" step="5" class="w-full h-1.5">
        </div>
    </div>
    <div id="chantingControls" class="mb-5 hidden space-y-3 p-3 bg-gray-700 bg-opacity-50 rounded-lg border border-gray-600">
        <h3 class="text-sm font-semibold text-purple-200 mb-2 border-b border-gray-600 pb-1">Chanting Settings</h3>
        <div>
            <label for="rhythmPattern" class="block mb-1 text-xs font-medium text-purple-200">Rhythm Pattern:</label>
            <select id="rhythmPattern">
                <option value="fourOnFloor">Four on the Floor</option>
                <option value="syncopated">Syncopated Beat</option>
                <option value="technoBasic">Techno Basic</option>
                <option value="breakbeatSimple">Simple Break</option>
            </select>
        </div>
    </div>
    <div id="singingControls" class="mb-5 hidden space-y-3 p-3 bg-gray-700 bg-opacity-50 rounded-lg border border-gray-600">
        <h3 class="text-sm font-semibold text-purple-200 mb-2 border-b border-gray-600 pb-1">Singing Settings</h3>
        <div>
            <label for="chordProgression" class="block mb-1 text-xs font-medium text-purple-200">Chord Progression:</label>
            <select id="chordProgression">
                <option value="AmGCF">Am - G - C - F</option>
                <option value="CmajLoop">Cmaj Loop</option>
                <option value="minorKey">Minor Key (i-VI-III-VII)</option>
                <option value="modalMix">Modal Mix</option>
            </select>
        </div>
    </div>

    <div class="space-y-4 mt-5">
        <div> <label for="consonantProb" class="block mb-1 text-sm font-medium text-purple-200">Consonant Probability: <span id="consonantProbValue">30</span>%</label>
            <input type="range" id="consonantProb" min="0" max="100" value="30" step="5" class="w-full h-1.5">
        </div>
        <div>
            <label for="voiceCount" class="block mb-1 text-sm font-medium text-purple-200">Voices/Layers: <span id="voiceCountValue">2</span></label>
            <input type="range" id="voiceCount" min="1" max="8" value="2" class="w-full h-1.5">
        </div>
        <div>
            <label for="tempo" class="block mb-1 text-sm font-medium text-purple-200">Tempo (BPM): <span id="tempoValue">80</span></label>
            <input type="range" id="tempo" min="30" max="180" value="80" step="5" class="w-full h-1.5">
        </div>
        <div>
            <label for="basePitch" class="block mb-1 text-sm font-medium text-purple-200">Base Pitch (Vowels): <span id="basePitchValue">120</span> Hz</label>
            <input type="range" id="basePitch" min="50" max="400" value="120" step="5" class="w-full h-1.5">
        </div>
        <div>
            <label for="pitchRandomness" class="block mb-1 text-sm font-medium text-purple-200">Pitch Randomness: <span id="pitchRangeValue">10</span></label>
            <input type="range" id="pitchRandomness" min="0" max="100" value="10" step="2" class="w-full h-1.5">
        </div>
        <div>
            <label for="portamento" class="block mb-1 text-sm font-medium text-purple-200">Glide/Portamento: <span id="portamentoValue">30</span> ms</label>
            <input type="range" id="portamento" min="0" max="200" value="30" step="5" class="w-full h-1.5">
        </div>
        <div>
            <label for="volume" class="block mb-1 text-sm font-medium text-purple-200">Volume: <span id="volumeValue">60</span>%</label>
            <input type="range" id="volume" min="0" max="100" value="60" class="w-full h-1.5">
        </div>
        <div>
            <label for="panningWidth" class="block mb-1 text-sm font-medium text-purple-200">Stereo Width: <span id="panningWidthValue">40</span></label>
            <input type="range" id="panningWidth" min="0" max="100" value="40" class="w-full h-1.5">
        </div>
        <div>
            <label for="reverbAmount" class="block mb-1 text-sm font-medium text-purple-200">Reverb Amount: <span id="reverbAmountValue">40</span>%</label>
            <input type="range" id="reverbAmount" min="0" max="100" value="40" step="5" class="w-full h-1.5">
        </div>
        <div>
            <label for="visualIntensity" class="block mb-1 text-sm font-medium text-purple-200">Visual Intensity: <span id="visualIntensityValue">40</span></label>
            <input type="range" id="visualIntensity" min="0" max="100" value="40" class="w-full h-1.5">
        </div>
    </div>
</div>

<script>
    // --- DOM Elements ---
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const statusDiv = document.getElementById('status');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');

    // Control Elements & Value Displays
    const controls = {
        mode: () => document.querySelector('input[name="mode"]:checked').value,
        prayerScale: document.getElementById('prayerScale'), // New
        wordLength: document.getElementById('wordLength'), // New
        phraseLength: document.getElementById('phraseLength'), // New
        intonationAmount: document.getElementById('intonationAmount'), // New
        rhythmPattern: document.getElementById('rhythmPattern'),
        chordProgression: document.getElementById('chordProgression'),
        consonantProb: document.getElementById('consonantProb'),
        voiceCount: document.getElementById('voiceCount'),
        tempo: document.getElementById('tempo'),
        basePitch: document.getElementById('basePitch'),
        pitchRandomness: document.getElementById('pitchRandomness'),
        portamento: document.getElementById('portamento'), // New
        volume: document.getElementById('volume'),
        panningWidth: document.getElementById('panningWidth'),
        reverbAmount: document.getElementById('reverbAmount'), // New
        visualIntensity: document.getElementById('visualIntensity'),
    };
    const valueDisplays = {
        wordLength: document.getElementById('wordLengthValue'), // New
        phraseLength: document.getElementById('phraseLengthValue'), // New
        intonationAmount: document.getElementById('intonationAmountValue'), // New
        consonantProb: document.getElementById('consonantProbValue'),
        voiceCount: document.getElementById('voiceCountValue'),
        tempo: document.getElementById('tempoValue'),
        basePitch: document.getElementById('basePitchValue'),
        pitchRandomness: document.getElementById('pitchRangeValue'),
        portamento: document.getElementById('portamentoValue'), // New
        volume: document.getElementById('volumeValue'),
        panningWidth: document.getElementById('panningWidthValue'),
        reverbAmount: document.getElementById('reverbAmountValue'), // New
        visualIntensity: document.getElementById('visualIntensityValue'),
    };
    const prayerControlsDiv = document.getElementById('prayerControls'); // New
    const chantingControlsDiv = document.getElementById('chantingControls');
    const singingControlsDiv = document.getElementById('singingControls');

    // --- State Variables ---
    let audioContext;
    let masterGain;
    let convolver; // For reverb
    let reverbGain; // Gain control for reverb wet signal
    let isRunning = false;
    let currentSettings = {};
    let noiseBuffer = null;
    let reverbBuffer = null;
    let visualAnimationId = null;

    // --- Sequencer State ---
    let schedulerState = {
        nextNoteTime: 0.0,
        currentStep: 0, // General step counter
        stepsPerPhrase: 16, // Default, adjusted by mode/tempo
        currentWordPhonemeIndex: 0, // For prayer mode
        currentWordIndex: 0, // For prayer mode
        currentPhraseWords: [], // For prayer mode
        currentScaleNotes: [], // For prayer mode pitch
        currentPitchIndex: 0, // For prayer mode pitch
        currentChordIndex: 0, // For singing mode
        lookaheadTime: 0.1,
        scheduleInterval: 25,
        timerID: null
    };

    // --- Music & Phoneme Data ---
    const NOTE_OFFSETS = { 'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11 };
    const A4 = 440.0;
    const A4_MIDI = 69;

    function midiToFreq(midiNote) {
        return A4 * Math.pow(2, (midiNote - A4_MIDI) / 12.0);
    }

    function noteNameToMidi(noteName) {
        const notePart = noteName.slice(0, -1);
        const octavePart = parseInt(noteName.slice(-1), 10);
        if (isNaN(octavePart) || !(notePart in NOTE_OFFSETS)) return 60; // Default C4
        return NOTE_OFFSETS[notePart] + (octavePart + 1) * 12;
    }

    // Scales (MIDI note intervals relative to root)
    const SCALES = {
        'majorPenta': [0, 2, 4, 7, 9],        // C D E G A
        'minorPenta': [0, 3, 5, 7, 10],       // C Eb F G Bb
        'majorScale': [0, 2, 4, 5, 7, 9, 11], // C D E F G A B
        'harmonicMinor': [0, 2, 3, 5, 7, 8, 11], // C D Eb F G Ab B
        'mixolydian': [0, 2, 4, 5, 7, 9, 10]   // C D E F G A Bb
    };

    const CHORDS = { /* ... (same as before) ... */
        'Am': [57, 60, 64], 'G': [55, 59, 62], 'C': [60, 64, 67], 'F': [53, 57, 60],
        'Cmaj': [60, 64, 67], 'Dm': [62, 65, 69], 'Em': [64, 67, 71],
        'Bb': [58, 62, 65], 'Eb': [63, 67, 70]
    };
    const PROGRESSIONS = { /* ... (same as before) ... */
        'AmGCF': ['Am', 'G', 'C', 'F'], 'CmajLoop': ['Cmaj'],
        'minorKey': ['Am', 'F', 'C', 'G'], 'modalMix': ['Dm', 'G', 'Cmaj', 'F', 'Bb', 'Em', 'Am']
    };
    const RHYTHM_PATTERNS = { /* ... (same as before) ... */
        'fourOnFloor':    [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
        'syncopated':     [1,0,1,0, 0,1,0,0, 1,0,0,1, 0,1,0,0],
        'technoBasic':    [1,0,0,1, 1,0,0,1, 1,0,0,1, 1,1,0,1],
        'breakbeatSimple':[1,0,1,0, 1,1,0,0, 0,1,0,1, 1,0,1,0]
    };

    // Phoneme Data
    const VOWELS = ['aa', 'ee', 'oo', 'uh', 'ih', 'eh', 'oh']; // Added more vowels
    const FRICATIVES = ['s', 'sh', 'f', 'th', 'v', 'z']; // Added voiced fricatives
    const PLOSIVES = ['p', 't', 'k', 'b', 'd', 'g']; // Added voiced plosives
    const NASALS = ['m', 'n', 'ng']; // Added 'ng'
    const LIQUIDS = ['l', 'r']; // Added liquids
    const CONSONANTS = [...FRICATIVES, ...PLOSIVES, ...NASALS, ...LIQUIDS];

    // Approximate Formant Frequencies (Hz) F1, F2, F3 - Added more vowels
    const VOWEL_FORMANTS = {
        'aa': [700, 1200, 2600], 'ee': [300, 2300, 3000], 'oo': [300, 800, 2400],
        'uh': [500, 1400, 2500], 'ih': [400, 2000, 2800], 'eh': [550, 1800, 2700], // Added 'eh' like 'bet'
        'oh': [450, 900, 2500]  // Added 'oh' like 'boat'
    };
    const VOWEL_Q = 18; // Slightly higher Q for more resonance

    // --- Word Generation (Prayer Mode) ---
    function generateWord(maxLength) {
        const word = [];
        let length = 2 + Math.floor(Math.random() * (maxLength - 1));
        let isVowelNext = Math.random() < 0.7; // Start often with a vowel for softer attack

        for (let i = 0; i < length; i++) {
            if (isVowelNext) {
                word.push(VOWELS[Math.floor(Math.random() * VOWELS.length)]);
            } else {
                word.push(CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)]);
            }
            // Alternate strictly for simplicity, could add CVC, CCV etc. later
            isVowelNext = !isVowelNext;
        }
        // Ensure last phoneme is often a vowel or nasal/liquid for smoother ending
        if (PLOSIVES.includes(word[word.length - 1]) || FRICATIVES.includes(word[word.length - 1])) {
            if (Math.random() < 0.6) {
                word[word.length - 1] = VOWELS[Math.floor(Math.random() * VOWELS.length)];
            } else if (Math.random() < 0.8) {
                word[word.length - 1] = NASALS[Math.floor(Math.random() * NASALS.length)];
            }
        }
        return word;
    }

    function generatePhrase(numWords, maxWordLength) {
        const phrase = [];
        for (let i = 0; i < numWords; i++) {
            phrase.push(generateWord(maxWordLength));
        }
        return phrase;
    }


    // --- Visualizer ---
    let hue = 180; // Start with blue/purple hues
    let particles = [];
    const MAX_PARTICLES = 250; // Increased max particles

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    function createParticle(baseHue) {
        const intensityFactor = currentSettings.visualIntensity / 100;
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 1.5 * (1 + intensityFactor);
        return {
            x: canvas.width / 2, // Start near center
            y: canvas.height / 2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 1 + Math.random() * 4 * (1 + intensityFactor * 0.5),
            life: 80 + Math.random() * 150 * (1 + intensityFactor * 1.5),
            hue: (baseHue + (Math.random() - 0.5) * 80) % 360, // Wider hue variation
            opacity: 0.4 + Math.random() * 0.5
        };
    }

    function drawVisuals() {
        if (!ctx) return;

        // Fading background effect - less fade for more trails
        ctx.fillStyle = `rgba(10, 10, 20, ${0.08 - (currentSettings.visualIntensity / 2000)})`; // Darker, less opaque
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        hue = (hue + 0.3) % 360; // Slower hue cycle

        // Particle management
        const targetParticleCount = Math.floor(MAX_PARTICLES * (currentSettings.visualIntensity / 100));
        if (particles.length < targetParticleCount && particles.length < MAX_PARTICLES && Math.random() < 0.5) {
            // Add multiple particles at once for bursts
            for(let i=0; i< 3; i++) {
                if (particles.length < MAX_PARTICLES) particles.push(createParticle(hue));
            }
        }

        // Update and draw particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 1;
            p.opacity -= 0.003; // Slower fade out

            // Gravity / Attraction towards center (optional subtle effect)
            // const dx = canvas.width / 2 - p.x;
            // const dy = canvas.height / 2 - p.y;
            // p.vx += dx * 0.0001;
            // p.vy += dy * 0.0001;

            // Wrap edges instead of bounce
            if (p.x < 0) p.x = canvas.width;
            if (p.x > canvas.width) p.x = 0;
            if (p.y < 0) p.y = canvas.height;
            if (p.y > canvas.height) p.y = 0;


            if (p.life <= 0 || p.opacity <= 0) {
                particles.splice(i, 1); // Remove dead particle
            } else {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                // Brighter, more saturated colors
                ctx.fillStyle = `hsla(${p.hue}, 100%, 75%, ${p.opacity * (currentSettings.visualIntensity / 100 + 0.2)})`;
                // Add a subtle glow
                ctx.shadowColor = `hsla(${p.hue}, 100%, 75%, 0.5)`;
                ctx.shadowBlur = 5 + p.radius * 1.5;
                ctx.fill();
                // Reset shadow for next particle
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }
        }
        visualAnimationId = requestAnimationFrame(drawVisuals);
    }


    // --- Audio Synthesis (Modified) ---
    function createSound(options = {}) {
        if (!audioContext || !masterGain) return;

        const now = options.startTime || audioContext.currentTime;
        const phoneme = options.phoneme || VOWELS[0]; // Default to 'aa'
        const startFreq = options.startFreq || currentSettings.basePitch;
        const endFreq = options.endFreq || startFreq; // For pitch glide
        const maxGain = 0.5; // Slightly increased max gain
        let duration = options.duration || 0.2;
        const portamentoTime = currentSettings.portamento / 1000.0; // Glide time in seconds

        // Nodes
        const panner = audioContext.createStereoPanner();
        const mainGain = audioContext.createGain();
        mainGain.connect(panner);
        // Connect to Reverb and Master Gain
        if (convolver && reverbGain) {
            panner.connect(reverbGain); // Send signal to reverb
        }
        panner.connect(masterGain); // Also connect directly to master (dry signal)


        // Set panning
        const panValue = (Math.random() - 0.5) * 2 * (currentSettings.panningWidth / 100);
        try {
            panner.pan.setValueAtTime(panValue, now);
        } catch (e) { console.warn("Error setting panner value:", e); return; }

        // --- Phoneme Type Switch ---
        let sourceNodes = [];
        let mainOscillatorNode = null; // To control frequency ramps

        try {
            if (VOWELS.includes(phoneme)) {
                const osc = audioContext.createOscillator();
                mainOscillatorNode = osc; // Assign for frequency control
                osc.type = 'sine'; // Use sine for smoother, fundamental tone initially
                // Add harmonics with another oscillator for richness
                const osc2 = audioContext.createOscillator();
                osc2.type = 'sawtooth';
                const osc2Gain = audioContext.createGain();
                osc2Gain.gain.setValueAtTime(0.3, now); // Harmonic volume
                osc.connect(osc2Gain); // Main osc modulates harmonic volume slightly? No, connect directly.
                osc2.connect(osc2Gain);
                osc2Gain.connect(mainGain); // Connect harmonics gain to main gain


                // Set initial frequency
                osc.frequency.setValueAtTime(Math.max(20, startFreq), now);
                osc2.frequency.setValueAtTime(Math.max(40, startFreq * 2), now); // Octave higher harmonic

                // Apply pitch glide (portamento) if start and end frequencies differ
                if (startFreq !== endFreq && portamentoTime > 0) {
                    const glideEndTime = now + Math.min(duration, portamentoTime);
                    osc.frequency.linearRampToValueAtTime(Math.max(20, endFreq), glideEndTime);
                    osc2.frequency.linearRampToValueAtTime(Math.max(40, endFreq * 2), glideEndTime);
                } else {
                    // If no glide, ensure frequency is set for duration
                    osc.frequency.setValueAtTime(Math.max(20, endFreq), now + duration * 0.01); // Set slightly after start
                    osc2.frequency.setValueAtTime(Math.max(40, endFreq * 2), now + duration * 0.01);
                }


                const formants = VOWEL_FORMANTS[phoneme] || VOWEL_FORMANTS['uh'];
                const formantGainValue = 1.0 / formants.length; // Normalize gain

                formants.forEach((fFreq) => {
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    const randomFactor = 1 + (Math.random() - 0.5) * 0.05; // Less randomness
                    filter.frequency.setValueAtTime(fFreq * randomFactor, now);
                    filter.Q.setValueAtTime(VOWEL_Q + (Math.random()-0.5)*3, now);

                    const filterGain = audioContext.createGain();
                    filterGain.gain.setValueAtTime(formantGainValue, now);

                    // Connect both oscillators to the formant filters
                    osc.connect(filter);
                    // osc2Gain.connect(filter); // Connect harmonic gain here too
                    filter.connect(filterGain);
                    filterGain.connect(mainGain);
                    sourceNodes.push(filter, filterGain);
                });

                // Longer, smoother envelope for prayer/praise feel
                const attack = 0.05 + Math.random()*0.05;
                const release = 0.1 + Math.random()*0.1;
                duration = Math.max(duration, attack + release + 0.05); // Ensure duration accommodates envelope
                mainGain.gain.setValueAtTime(0, now);
                mainGain.gain.linearRampToValueAtTime(maxGain, now + attack);
                mainGain.gain.setValueAtTime(maxGain, now + duration - release); // Hold gain longer
                mainGain.gain.linearRampToValueAtTime(0, now + duration);

                osc.start(now);
                osc.stop(now + duration);
                osc2.start(now);
                osc2.stop(now + duration);
                sourceNodes.push(osc, osc2, osc2Gain);

            } else if (CONSONANTS.includes(phoneme)) {
                if (!noiseBuffer) return;
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true; // Loop for fricatives/nasals if needed

                const filter = audioContext.createBiquadFilter();
                let filterFreq = 3000, filterQ = 1, gainMultiplier = 0.6;
                duration = 0.05 + Math.random() * 0.05; // Consonants are shorter

                if (FRICATIVES.includes(phoneme)) {
                    filter.type = ['s', 'z'].includes(phoneme) ? 'highpass' : 'bandpass';
                    filterFreq = 3500 + Math.random() * 2500;
                    filterQ = ['sh', 'f', 'v'].includes(phoneme) ? 4 : 1;
                    noise.loop = true; // Fricatives sustain
                    duration = 0.08 + Math.random() * 0.07;
                    gainMultiplier = 0.5;
                } else if (PLOSIVES.includes(phoneme)) {
                    filter.type = 'highpass';
                    filterFreq = 1500 + Math.random() * 3000;
                    noise.loop = false; // Plosives are short bursts
                    duration = 0.02 + Math.random() * 0.02;
                    gainMultiplier = 0.7;
                } else if (NASALS.includes(phoneme)) {
                    // Nasals have a pitched component + filtered noise
                    const nasalOsc = audioContext.createOscillator();
                    mainOscillatorNode = nasalOsc; // Assign for frequency control
                    nasalOsc.type = 'triangle';
                    nasalOsc.frequency.setValueAtTime(Math.max(20, startFreq * 0.9), now); // Slightly lower pitch
                    if (startFreq !== endFreq && portamentoTime > 0) {
                        const glideEndTime = now + Math.min(duration, portamentoTime);
                        nasalOsc.frequency.linearRampToValueAtTime(Math.max(20, endFreq * 0.9), glideEndTime);
                    } else {
                        nasalOsc.frequency.setValueAtTime(Math.max(20, endFreq * 0.9), now + duration * 0.01);
                    }

                    filter.type = 'lowpass';
                    filterFreq = 600 + Math.random() * 400;
                    filterQ = 2 + Math.random();
                    noise.connect(filter); // Noise part
                    filter.connect(mainGain);
                    nasalOsc.connect(mainGain); // Pitched part
                    sourceNodes.push(nasalOsc, filter);
                    nasalOsc.start(now);
                    nasalOsc.stop(now + duration);
                    duration = 0.1 + Math.random() * 0.1; // Nasals are longer than plosives
                    gainMultiplier = 0.6;
                } else if (LIQUIDS.includes(phoneme)) {
                    // Liquids similar to nasals but maybe higher/brighter filter
                    const liquidOsc = audioContext.createOscillator();
                    mainOscillatorNode = liquidOsc; // Assign for frequency control
                    liquidOsc.type = 'sine';
                    liquidOsc.frequency.setValueAtTime(Math.max(20, startFreq), now);
                    if (startFreq !== endFreq && portamentoTime > 0) {
                        const glideEndTime = now + Math.min(duration, portamentoTime);
                        liquidOsc.frequency.linearRampToValueAtTime(Math.max(20, endFreq), glideEndTime);
                    } else {
                        liquidOsc.frequency.setValueAtTime(Math.max(20, endFreq), now + duration * 0.01);
                    }

                    filter.type = 'bandpass';
                    filterFreq = 1000 + Math.random() * 800;
                    filterQ = 3 + Math.random();
                    noise.connect(filter); // Noise part for 'r' like quality
                    filter.connect(mainGain);
                    liquidOsc.connect(mainGain); // Pitched part
                    sourceNodes.push(liquidOsc, filter);
                    liquidOsc.start(now);
                    liquidOsc.stop(now + duration);
                    duration = 0.1 + Math.random() * 0.1;
                    gainMultiplier = 0.5;
                }

                if (!NASALS.includes(phoneme) && !LIQUIDS.includes(phoneme)) {
                    filter.frequency.setValueAtTime(filterFreq, now);
                    filter.Q.setValueAtTime(filterQ, now);
                    noise.connect(filter);
                    filter.connect(mainGain);
                    sourceNodes.push(filter);
                }

                // Envelope for consonants
                const attack = 0.005;
                const release = duration * 0.5;
                mainGain.gain.setValueAtTime(0, now);
                mainGain.gain.linearRampToValueAtTime(maxGain * gainMultiplier, now + attack);
                mainGain.gain.setValueAtTime(maxGain * gainMultiplier, now + duration - release);
                mainGain.gain.linearRampToValueAtTime(0, now + duration);

                noise.start(now);
                noise.stop(now + (noise.loop ? duration : 0.1)); // Stop noise shortly after if not looping
                sourceNodes.push(noise);

            } else {
                console.warn("Unknown phoneme:", phoneme);
            }

            // Cleanup
            const cleanupTime = now + duration + 0.2; // Increased cleanup delay
            setTimeout(() => {
                try {
                    mainGain.disconnect();
                    panner.disconnect();
                    sourceNodes.forEach(node => node.disconnect());
                } catch(e) { /* ignore */ }
            }, (cleanupTime - audioContext.currentTime) * 1000);

        } catch (error) {
            console.error("Error creating sound:", error, "Phoneme:", phoneme, "Options:", options);
            try { // Attempt cleanup on error
                mainGain.disconnect(); panner.disconnect(); sourceNodes.forEach(node => node.disconnect());
            } catch(e) {}
        }
    }


    // --- Sequencer Logic (Modified) ---

    function getScaleNotes(scaleName, rootMidiNote) {
        const intervals = SCALES[scaleName] || SCALES.majorPenta;
        return intervals.map(interval => rootMidiNote + interval);
    }

    function scheduleNote(noteTime) {
        const mode = currentSettings.mode;
        const voiceCount = currentSettings.voiceCount;
        const baseNoteDuration = (60.0 / currentSettings.tempo) / 4; // 16th note duration

        try {
            if (mode === 'prayer') {
                // Check if we need to generate a new phrase
                if (schedulerState.currentWordIndex === 0 && schedulerState.currentWordPhonemeIndex === 0) {
                    schedulerState.currentPhraseWords = generatePhrase(currentSettings.phraseLength, currentSettings.wordLength);
                    // Select root note based on basePitch (find nearest C)
                    const baseMidi = Math.round(A4_MIDI + 12 * Math.log2(currentSettings.basePitch / A4));
                    const rootMidiNote = Math.round(baseMidi / 12) * 12; // Find nearest C
                    schedulerState.currentScaleNotes = getScaleNotes(currentSettings.prayerScale, rootMidiNote);
                    schedulerState.currentPitchIndex = Math.floor(Math.random() * schedulerState.currentScaleNotes.length); // Start on random scale note
                }

                const currentWord = schedulerState.currentPhraseWords[schedulerState.currentWordIndex];
                const phoneme = currentWord[schedulerState.currentWordPhonemeIndex];

                // Determine pitch and duration
                let midiNote = schedulerState.currentScaleNotes[schedulerState.currentPitchIndex % schedulerState.currentScaleNotes.length];
                let nextMidiNote = midiNote;
                let duration = baseNoteDuration * (VOWELS.includes(phoneme) ? (1.5 + Math.random() * 1.5) : (0.5 + Math.random() * 0.5)); // Vowels longer

                // Intonation: Change pitch slightly between phonemes/words
                const intonationFactor = currentSettings.intonationAmount / 100.0;
                if (Math.random() < 0.4 * intonationFactor) { // Chance to change pitch
                    // Move stepwise in the scale mostly
                    const step = (Math.random() < 0.5 ? -1 : 1) * (Math.random() < 0.7 ? 1 : 2); // Small steps more likely
                    schedulerState.currentPitchIndex += step;
                    // Keep index within reasonable bounds (e.g., 2 octaves)
                    schedulerState.currentPitchIndex = Math.max(0, Math.min(schedulerState.currentScaleNotes.length * 2 -1, schedulerState.currentPitchIndex));
                    nextMidiNote = schedulerState.currentScaleNotes[schedulerState.currentPitchIndex % schedulerState.currentScaleNotes.length];
                    // Add octave shift based on index
                    nextMidiNote += 12 * Math.floor(schedulerState.currentPitchIndex / schedulerState.currentScaleNotes.length);
                }

                // Add slight random pitch variation per voice
                const randomPitchOffset = (Math.random() - 0.5) * currentSettings.pitchRandomness;

                for (let i = 0; i < voiceCount; i++) {
                    // Add slight detuning and timing variation between voices
                    const voiceTimeOffset = (Math.random() - 0.5) * 0.01;
                    const voicePitchOffset = (Math.random() - 0.5) * 3; // Small Hz detune

                    const startFreq = midiToFreq(midiNote + randomPitchOffset) + voicePitchOffset;
                    const endFreq = midiToFreq(nextMidiNote + randomPitchOffset) + voicePitchOffset;

                    createSound({
                        startTime: noteTime + voiceTimeOffset,
                        phoneme: phoneme,
                        startFreq: startFreq,
                        endFreq: endFreq, // Pass end frequency for glide
                        duration: duration * (1 + (Math.random() - 0.5) * 0.1) // Slight duration variation
                    });
                }

                // Advance word/phrase state
                schedulerState.currentWordPhonemeIndex++;
                if (schedulerState.currentWordPhonemeIndex >= currentWord.length) {
                    schedulerState.currentWordPhonemeIndex = 0;
                    schedulerState.currentWordIndex++;
                    // Add a slight pause between words
                    schedulerState.nextNoteTime += baseNoteDuration * (1 + Math.random());
                    if (schedulerState.currentWordIndex >= schedulerState.currentPhraseWords.length) {
                        schedulerState.currentWordIndex = 0;
                        // Add a longer pause between phrases
                        schedulerState.nextNoteTime += baseNoteDuration * (3 + Math.random() * 3);
                    }
                }
                // Set next note time based on duration, not fixed step
                schedulerState.nextNoteTime += duration;


            } else if (mode === 'chanting') {
                const patternName = currentSettings.rhythmPattern;
                const pattern = RHYTHM_PATTERNS[patternName] || RHYTHM_PATTERNS.fourOnFloor;
                const stepIndex = schedulerState.currentStep % pattern.length;

                if (pattern[stepIndex] === 1) {
                    for(let i=0; i<voiceCount; i++){
                        const forceConsonant = (stepIndex + i) % 4 === 0; // Keep consonant emphasis
                        const phoneme = getRandomPhoneme(forceConsonant); // Use original random phoneme logic
                        const targetFreq = currentSettings.basePitch + (Math.random() - 0.5) * currentSettings.pitchRandomness;
                        const duration = baseNoteDuration * (VOWELS.includes(phoneme) ? 1.5 : 0.8);
                        createSound({ startTime: noteTime, phoneme: phoneme, startFreq: targetFreq, endFreq: targetFreq, duration: duration });
                    }
                }
                // Advance sequencer state for chanting (fixed grid)
                schedulerState.nextNoteTime += baseNoteDuration;
                schedulerState.currentStep++;


            } else if (mode === 'singing') {
                const progressionName = currentSettings.chordProgression;
                const progression = PROGRESSIONS[progressionName] || PROGRESSIONS.AmGCF;
                const chordName = progression[schedulerState.currentChordIndex % progression.length];
                const chordNotes = CHORDS[chordName] || CHORDS.Am;
                const stepIndex = schedulerState.currentStep % 16; // 16 steps per measure

                // Trigger notes on certain steps (e.g., downbeats, some syncopation)
                if (stepIndex % 4 === 0 || (stepIndex % 2 === 0 && Math.random() < 0.3) ) {
                    for(let i=0; i<voiceCount; i++){
                        const noteIndex = Math.floor(Math.random() * chordNotes.length); // Pick random note from chord
                        let midiNote = chordNotes[noteIndex];
                        // Adjust octave based on basePitch setting
                        const baseMidi = Math.round(A4_MIDI + 12 * Math.log2(currentSettings.basePitch / A4));
                        const octaveShift = Math.floor((baseMidi - 55) / 12); // Shift relative to approx A3
                        midiNote += octaveShift * 12;

                        const targetFreq = midiToFreq(midiNote + (Math.random() - 0.5) * currentSettings.pitchRandomness);
                        const phoneme = getRandomPhoneme(Math.random() < 0.1); // Mostly vowels
                        const noteDuration = baseNoteDuration * (stepIndex % 4 === 0 ? 4 : 2); // Longer notes on downbeats
                        createSound({ startTime: noteTime, phoneme: phoneme, startFreq: targetFreq, endFreq: targetFreq, duration: noteDuration });
                    }
                }
                // Advance sequencer state for singing
                schedulerState.nextNoteTime += baseNoteDuration;
                schedulerState.currentStep++;
                if (schedulerState.currentStep % 16 === 0) { // Advance chord every measure (16 steps)
                    schedulerState.currentChordIndex++;
                }

            } else { // Ghost or Random modes - use original random logic
                if (Math.random() < (currentSettings.tempo / 500 + 0.05)) { // Adjusted probability
                    for(let i=0; i<voiceCount; i++){
                        const phoneme = getRandomPhoneme(); // Original random phoneme
                        const targetFreq = currentSettings.basePitch + (Math.random() - 0.5) * currentSettings.pitchRandomness * 2; // More randomness maybe
                        const duration = 0.1 + Math.random() * 0.4;
                        createSound({ startTime: noteTime, phoneme: phoneme, startFreq: targetFreq, endFreq: targetFreq, duration: duration });
                    }
                }
                // Advance sequencer state for random modes
                schedulerState.nextNoteTime += baseNoteDuration * (0.5 + Math.random()); // Irregular timing
                schedulerState.currentStep++;
            }
        } catch (error) {
            console.error("Error in scheduleNote:", error);
        }
    }

    // Original getRandomPhoneme function for other modes
    function getRandomPhoneme(forceConsonant = false) {
        const consonantProbability = currentSettings.consonantProb / 100.0;
        const isConsonant = forceConsonant || Math.random() < consonantProbability;

        if (isConsonant) {
            return CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];
        } else {
            return VOWELS[Math.floor(Math.random() * VOWELS.length)];
        }
    }


    function scheduler() {
        try {
            while (schedulerState.nextNoteTime < audioContext.currentTime + schedulerState.lookaheadTime) {
                scheduleNote(schedulerState.nextNoteTime);
                // Note: nextNoteTime is now advanced within scheduleNote based on mode/duration
            }
        } catch (error) {
            console.error("Error in scheduler loop:", error);
        }
        if (isRunning) {
            schedulerState.timerID = setTimeout(scheduler, schedulerState.scheduleInterval);
        } else {
            schedulerState.timerID = null;
        }
    }

    // --- Control Handling ---
    function updateSettings() {
        currentSettings = {
            mode: controls.mode(),
            prayerScale: controls.prayerScale.value,
            wordLength: parseInt(controls.wordLength.value, 10),
            phraseLength: parseInt(controls.phraseLength.value, 10),
            intonationAmount: parseInt(controls.intonationAmount.value, 10),
            rhythmPattern: controls.rhythmPattern.value,
            chordProgression: controls.chordProgression.value,
            consonantProb: parseInt(controls.consonantProb.value, 10),
            voiceCount: parseInt(controls.voiceCount.value, 10),
            tempo: parseInt(controls.tempo.value, 10),
            basePitch: parseInt(controls.basePitch.value, 10),
            pitchRandomness: parseInt(controls.pitchRandomness.value, 10),
            portamento: parseInt(controls.portamento.value, 10),
            volume: parseInt(controls.volume.value, 10),
            panningWidth: parseInt(controls.panningWidth.value, 10),
            reverbAmount: parseInt(controls.reverbAmount.value, 10),
            visualIntensity: parseInt(controls.visualIntensity.value, 10),
        };

        // Update value displays
        valueDisplays.wordLength.textContent = currentSettings.wordLength;
        valueDisplays.phraseLength.textContent = currentSettings.phraseLength;
        valueDisplays.intonationAmount.textContent = currentSettings.intonationAmount;
        valueDisplays.consonantProb.textContent = currentSettings.consonantProb;
        valueDisplays.voiceCount.textContent = currentSettings.voiceCount;
        valueDisplays.tempo.textContent = currentSettings.tempo;
        valueDisplays.basePitch.textContent = currentSettings.basePitch;
        valueDisplays.pitchRandomness.textContent = currentSettings.pitchRandomness;
        valueDisplays.portamento.textContent = currentSettings.portamento;
        valueDisplays.volume.textContent = currentSettings.volume;
        valueDisplays.panningWidth.textContent = currentSettings.panningWidth;
        valueDisplays.reverbAmount.textContent = currentSettings.reverbAmount;
        valueDisplays.visualIntensity.textContent = currentSettings.visualIntensity;

        // Show/Hide mode-specific controls
        prayerControlsDiv.classList.toggle('hidden', currentSettings.mode !== 'prayer');
        chantingControlsDiv.classList.toggle('hidden', currentSettings.mode !== 'chanting');
        singingControlsDiv.classList.toggle('hidden', currentSettings.mode !== 'singing');

        // Apply volume and reverb changes
        if (masterGain && audioContext && audioContext.state === 'running') {
            try {
                masterGain.gain.setTargetAtTime(currentSettings.volume / 100, audioContext.currentTime, 0.05);
                if (reverbGain) {
                    // Adjust reverb wet level (using an equal-power curve approximation)
                    const wetLevel = Math.sin((currentSettings.reverbAmount / 100) * (Math.PI / 2));
                    reverbGain.gain.setTargetAtTime(wetLevel, audioContext.currentTime, 0.05);
                    // Adjust dry level slightly to maintain perceived loudness
                    // const dryLevel = Math.cos((currentSettings.reverbAmount / 100) * (Math.PI / 2));
                    // masterGain.gain.setTargetAtTime(dryLevel * (currentSettings.volume / 100), audioContext.currentTime, 0.05);
                    // Simpler approach: Just control master gain and wet gain separately.
                }
            } catch(e) { console.warn("Error setting gain/reverb:", e); }
        }

        // Reset scheduler state if mode changes to ensure clean transition
        // This is handled in the radio button event listener below.
    }

    // Add event listeners to controls
    Object.values(controls).forEach(control => {
        if (control && typeof control !== 'function') {
            control.addEventListener('input', updateSettings);
        }
    });
    document.querySelectorAll('input[name="mode"]').forEach(radio => {
        radio.addEventListener('change', () => {
            updateSettings();
            // Reset scheduler state when mode changes
            if (audioContext) {
                schedulerState.currentStep = 0;
                schedulerState.currentWordPhonemeIndex = 0;
                schedulerState.currentWordIndex = 0;
                schedulerState.currentPhraseWords = [];
                schedulerState.currentChordIndex = 0;
                schedulerState.nextNoteTime = audioContext.currentTime + 0.1; // Reset time slightly ahead
                // Clear any pending notes from the old mode immediately
                clearTimeout(schedulerState.timerID);
                if (isRunning) { // Reschedule only if running
                    scheduler();
                }
            }
        });
    });


    // --- Pre-generate Noise & Reverb ---
    function createNoiseBuffer(context) {
        if (!context) return null;
        const bufferSize = context.sampleRate * 1; // 1 second is enough
        const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1; // White noise
        }
        return buffer;
    }

    // Generate a simple impulse response for reverb
    function createReverbBuffer(context) {
        if (!context) return null;
        const sampleRate = context.sampleRate;
        const duration = 1.5; // Reverb tail duration in seconds
        const decay = 3.0; // How quickly the reverb decays
        const bufferSize = sampleRate * duration;
        const buffer = context.createBuffer(2, bufferSize, sampleRate); // Stereo reverb

        for (let channel = 0; channel < 2; channel++) {
            const output = buffer.getChannelData(channel);
            for (let i = 0; i < bufferSize; i++) {
                // Simple exponential decay noise
                output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, decay);
            }
        }
        return buffer;
    }


    // --- Start/Stop Logic ---
    startButton.addEventListener('click', async () => { // Make async for resume/buffer loading
        if (isRunning) return;
        try {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Master Gain (Dry signal path)
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);

                // Reverb Path
                convolver = audioContext.createConvolver();
                reverbGain = audioContext.createGain(); // Wet signal gain
                reverbGain.connect(masterGain); // Connect wet signal back before destination
                convolver.connect(reverbGain);

                // Generate buffers
                noiseBuffer = createNoiseBuffer(audioContext);
                reverbBuffer = createReverbBuffer(audioContext);
                if (!noiseBuffer || !reverbBuffer) {
                    throw new Error("Failed to create audio buffers.");
                }
                convolver.buffer = reverbBuffer; // Assign impulse response
            }

            // Resume context if needed (required after user interaction)
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
                console.log("AudioContext resumed.");
            }

            if (audioContext.state === 'running') {
                startSequencerAndVisuals();
            } else {
                throw new Error("AudioContext could not be started or resumed.");
            }

        } catch (error) {
            console.error("Error starting audio:", error);
            statusDiv.textContent = `Error: ${error.message}`;
            isRunning = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            // Clean up partial audio setup if error occurred
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.warn("Error closing context on start failure:", e));
                audioContext = null; masterGain = null; convolver = null; reverbGain = null; noiseBuffer = null; reverbBuffer = null;
            }
        }
    });


    function startSequencerAndVisuals() {
        if (isRunning) return; // Prevent double start

        isRunning = true;
        statusDiv.textContent = 'Running...';
        startButton.disabled = true;
        stopButton.disabled = false;

        updateSettings(); // Apply initial settings (volume, reverb etc.)

        // Start Sequencer
        schedulerState.currentStep = 0;
        schedulerState.currentWordPhonemeIndex = 0;
        schedulerState.currentWordIndex = 0;
        schedulerState.currentPhraseWords = [];
        schedulerState.currentChordIndex = 0;
        schedulerState.nextNoteTime = audioContext.currentTime + 0.1; // Start scheduling slightly ahead
        clearTimeout(schedulerState.timerID);
        scheduler(); // Start the scheduler loop

        // Start Visuals
        if (!visualAnimationId) {
            resizeCanvas();
            particles = []; // Clear old particles
            drawVisuals();
        }
    }


    stopButton.addEventListener('click', () => {
        if (!isRunning) return;
        isRunning = false;
        statusDiv.textContent = 'Stopping...';

        // Stop Sequencer
        clearTimeout(schedulerState.timerID);
        schedulerState.timerID = null;

        // Fade out master volume smoothly
        if (masterGain && audioContext && audioContext.state === 'running') {
            try {
                masterGain.gain.cancelScheduledValues(audioContext.currentTime);
                masterGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.3); // Longer fade out
                if(reverbGain) { // Also fade out reverb gain
                    reverbGain.gain.cancelScheduledValues(audioContext.currentTime);
                    reverbGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.3);
                }
            } catch(e) { console.warn("Error fading out gain:", e); }
        }

        // Update UI after fade out
        setTimeout(() => {
            statusDiv.textContent = 'Stopped';
            startButton.disabled = false;
            stopButton.disabled = true;
            // Optionally suspend context after a delay to save resources
            // if (audioContext && audioContext.state === 'running') {
            //    setTimeout(() => audioContext.suspend(), 1000);
            // }
        }, 400);

        // Keep visuals running idly or stop them:
        // To stop visuals:
        // if (visualAnimationId) {
        //     cancelAnimationFrame(visualAnimationId);
        //     visualAnimationId = null;
        // }
    });

    // --- Initialization ---
    updateSettings(); // Initialize settings display on load
    stopButton.disabled = true;
    resizeCanvas(); // Initial canvas size

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (isRunning) {
            stopButton.click(); // Trigger stop logic cleanly
        }
        if (visualAnimationId) {
            cancelAnimationFrame(visualAnimationId);
            visualAnimationId = null;
        }
        // Attempt to close audio context cleanly
        if (audioContext && audioContext.state !== 'closed') {
            // Use a short delay to allow stop fadeout to potentially complete
            setTimeout(() => {
                audioContext.close().catch(e => console.warn("Error closing AudioContext:", e));
            }, 500);
        }
    });

</script>
</body>
</html>
