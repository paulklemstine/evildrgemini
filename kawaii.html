<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kawaii Heart Adventures - HTML Deluxe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&family=Playfair+Display:wght@700&display=swap"
          rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.css">
    <style>
        /* Embedded styles adapted for Kawaii/Loving/Erotic theme + Multi-Image */
        body {
            font-family: 'Nunito', sans-serif; /* Cuter font */
            background: linear-gradient(135deg, #ffdde1 0%, #ee9ca7 100%); /* Pink gradient background */
            color: #583c5a; /* Dark pink/purple text */
            margin: 0;
            padding: 0;
        }

        /* Header Styling */
        .site-header { padding: 0; margin-bottom: 1rem; text-align: center; position: relative; overflow: hidden; }
        .header-banner-image { width: 100%; height: 120px; object-fit: cover; display: block; opacity: 0.8; }
        .site-header h1 { font-family: 'Playfair Display', serif; font-size: 2.8rem; color: #ffffff; text-shadow: 1px 1px 5px rgba(224, 82, 99, 0.8); margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; padding: 0 1rem; box-sizing: border-box; background: rgba(255, 105, 180, 0.5); padding-top: 0.4rem; padding-bottom: 0.4rem; }

        /* Footer Styling */
        .site-footer { margin-top: 2rem; padding: 1.5rem 1rem; text-align: center; font-size: 0.875rem; color: #8c5f8f; border-top: 1px solid #f4acb7; background-color: rgba(255, 255, 255, 0.3); }
        .footer-buttons { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; margin-bottom: 1rem; }
        #clipboardMessage { font-size: 0.8rem; color: #e11d48; height: 1.2em; font-weight: 600; margin-bottom: 1rem; }

        /* Game Layout */
        #game-container { display: flex; flex-direction: column; max-width: 1200px; margin: 0 auto; padding: 0 1rem; gap: 1rem; }

        /* Styling for elements potentially generated by LLM */
        .kawaii-card { background-color: rgba(255, 255, 255, 0.85) !important; color: #6d28d9; border: 1px solid #f4acb7; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); margin-bottom: 1.5rem; }
        .kawaii-card h2 { font-family: 'Nunito', sans-serif; color: #db2777; border-bottom: 2px dashed #f9a8d4; padding-bottom: 0.6rem; margin-bottom: 1.2rem; font-size: 1.6rem; font-weight: 700; text-align: center; flex-shrink: 0; }
        .kawaii-text { color: inherit; line-height: 1.7; word-wrap: break-word; font-size: 1rem; }
        .kawaii-text strong { color: #c026d3; font-weight: 700; } .kawaii-text em { color: #ea580c; font-style: italic; }
        .kawaii-text pre { background-color: #fdf4ff; padding: 0.8rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.85rem; color: #581c87; margin-top: 0.5rem; border: 1px solid #e9d5ff; }
        .kawaii-input, .kawaii-textarea { width: 100%; padding: 0.8rem; border: 1px solid #f9a8d4; border-radius: 0.5rem; color: #581c87; background-color: #faf5ff; font-family: 'Nunito', sans-serif; margin-bottom: 0.5rem; }
        .kawaii-input::placeholder, .kawaii-textarea::placeholder { color: #a855f7; opacity: 0.7; }
        .kawaii-input:focus, .kawaii-textarea:focus { outline: none; border-color: #e879f9; box-shadow: 0 0 0 3px rgba(232, 121, 249, 0.3); background-color: white; }
        .kawaii-textarea { min-height: 70px; }
        .kawaii-radio-option, .kawaii-checkbox-option { display: flex; align-items: center; margin-bottom: 0.6rem; padding: 0.7rem 1rem; border-radius: 0.75rem; cursor: pointer; transition: background-color 0.2s, transform 0.1s; border: 1px solid #fbcfe8; color: inherit; background-color: rgba(255, 255, 255, 0.9); }
        .kawaii-radio-option:hover, .kawaii-checkbox-option:hover { background-color: #fff1f2; border-color: #f9a8d4; }
        .kawaii-radio-option input[type="radio"], .kawaii-checkbox-option input[type="checkbox"] { margin-right: 0.8rem; cursor: pointer; accent-color: #f472b6; width: 1.1rem; height: 1.1rem; flex-shrink: 0; }
        /* Styling for the label associated with radio/checkbox */
        .kawaii-radio-option label, .kawaii-checkbox-option label { color: inherit; flex-grow: 1; cursor: pointer; font-weight: 600; }
        /* Ensure clicking label checks the input */
        .kawaii-radio-option label, .kawaii-checkbox-option label { display: flex; align-items: center; width: 100%; }

        .kawaii-slider { width: 100%; cursor: pointer; accent-color: #f472b6; height: 0.6rem; background: #fce7f3; border-radius: 9999px; appearance: none; -webkit-appearance: none; }
        .kawaii-slider::-webkit-slider-thumb { appearance: none; -webkit-appearance: none; width: 1.3rem; height: 1.3rem; background: var(--slider-thumb-color, #ec4899); border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .kawaii-slider::-moz-range-thumb { width: 1.3rem; height: 1.3rem; background: var(--slider-thumb-color, #ec4899); border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .kawaii-slider-value-display { color: #ec4899; font-weight: 700; min-width: 2rem; text-align: right; }
        .kawaii-image-container { margin-bottom: 1rem; text-align: center; }
        .kawaii-image { max-width: 100%; height: auto; border-radius: 0.75rem; background-color: #fff1f2; display: block; margin-left: auto; margin-right: auto; border: 2px solid #f9a8d4; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); }
        .kawaii-image-prompt { font-size: 0.8rem; color: #be185d; opacity: 0.9; font-style: italic; margin-top: 0.5rem; word-wrap: break-word; padding: 0 0.5rem; font-weight: 600; }
        .kawaii-image-label { font-size: 0.9rem; font-weight: 700; color: #a855f7; margin-bottom: 0.3rem; }

        /* Buttons */
        .kawaii-button {
            padding: 0.8rem 1.8rem; background: linear-gradient(to right, #ec4899, #d946ef); color: white; border: none; border-radius: 0.75rem; font-weight: 700; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.2); text-transform: uppercase; letter-spacing: 0.08em; white-space: nowrap; font-size: 0.9rem;
        }
        .kawaii-button:hover { background: linear-gradient(to right, #db2777, #c026d3); box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.25); transform: translateY(-2px) scale(1.03); }
        .kawaii-button:active { transform: translateY(0) scale(1); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2); }
        .kawaii-button:disabled { background: #e9d5ff; color: #a855f7; cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none; }
        #modeToggleButton { background: linear-gradient(to right, #fb7185, #f472b6); }
        #modeToggleButton.standard-mode { background: linear-gradient(to right, #a78bfa, #c084fc); }
        #resetGameButton { background: linear-gradient(to right, #f87171, #ef4444); }

        /* Loading/Error */
        .loading-indicator, .error-message { display: flex; justify-content: center; align-items: center; padding: 1rem; font-size: 1rem; border-radius: 0.75rem; margin-top: 1rem; font-weight: 600; }
        .loading-indicator { color: #be185d; background-color: #fff1f2; border: 1px solid #fbcfe8; }
        .loading-indicator svg { width: 1.25rem; height: 1.25rem; color: #ec4899; }
        .error-message { color: #9f1239; background-color: #ffe4e6; border: 1px solid #fda4af; text-align: center; white-space: pre-wrap; }

        /* API Key Section */
        #apiKeySection { margin-bottom: 1rem; background: rgba(255,255,255,0.4); padding: 1rem; border-radius: 0.75rem; border: 1px solid #f8bbd0; }
        #apiKeySection .api-key-label { color: #db2777; display: block; margin-bottom: 0.6rem; font-weight: 700; font-size: 1rem;} /* Adjusted class */
        #apiKeySection .api-key-instructions a { color: #be185d; text-decoration: underline; font-weight: 600; }
        #apiKeySection .api-key-instructions a:hover { color: #9d174d; }

        /* Styling for potential creative UI elements */
        .kawaii-toggle-switch { display: inline-flex; align-items: center; cursor: pointer; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        .kawaii-toggle-switch input { display: none; } /* Hide actual checkbox */
        .kawaii-toggle-switch .switch-bg { width: 50px; height: 26px; background-color: #fbcfe8; /* Light pink off */ border-radius: 13px; position: relative; transition: background-color 0.3s ease; border: 1px solid #f9a8d4; flex-shrink: 0; }
        .kawaii-toggle-switch .switch-handle { width: 22px; height: 22px; background-color: white; border-radius: 50%; position: absolute; top: 1px; left: 2px; transition: transform 0.3s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .kawaii-toggle-switch input:checked + .switch-bg { background-color: #f472b6; /* Pink on */ }
        .kawaii-toggle-switch input:checked + .switch-bg .switch-handle { transform: translateX(24px); }
        .kawaii-toggle-switch span { margin-left: 0.5rem; font-weight: 600; color: #be185d; }

        .kawaii-segmented-control { display: flex; border: 1px solid #f472b6; border-radius: 0.75rem; overflow: hidden; background-color: #fff1f2; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        .kawaii-segmented-control label { flex: 1; text-align: center; padding: 0.5rem 0.8rem; cursor: pointer; transition: background-color 0.2s, color 0.2s; font-weight: 600; color: #be185d; font-size: 0.9rem; }
        .kawaii-segmented-control input[type="radio"] { display: none; }
        .kawaii-segmented-control input[type="radio"]:checked + label { background-color: #f472b6; color: white; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .kawaii-segmented-control label:not(:last-child) { border-right: 1px solid #f9a8d4; }

    </style>
</head>
<body class="bg-pink-50 text-purple-800">

<header class="site-header">
    <img id="headerBanner" alt="Kawaii Sparkle Banner" class="header-banner-image">
    <h1>Kawaii Heart Adventures HTML</h1> </header>

<div class="max-w-6xl mx-auto px-4 md:px-8">
    <div id="apiKeySection">
        <label for="apiKeyInput" class="api-key-label api-key-instructions">
            Enter Google AI API Key to Start Your Adorable Adventure! ✨
            <span class="block text-sm font-normal text-purple-600 mt-1">
                (Get a key from Google AI Studio:
                <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer">
                    aistudio.google.com/apikey
                </a>)
                <br>Or provide via URL: ?apiKey=YOUR_API_KEY
            </span>
        </label>
        <input type="password" id="apiKeyInput" class="kawaii-input" placeholder="Paste your magic key here~ 💖">
    </div>

    <div id="game-container">
        <div id="turn-content">
            <div id="initial-message" class="text-center text-pink-500 p-4 font-semibold kawaii-card">
                Enter your API Key above and click "Start Adventure!" to begin!
                <br>Or, paste a saved adventure code into your browser console~
            </div>
        </div>

        <div id="loading" class="loading-indicator" style="display: none;">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none"
                 viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Generating cuteness... Please wait! ☆*:.｡.o(≧▽≦)o.｡.:*☆
        </div>
        <div id="error-display" class="error-message" style="display: none;"></div>

        <div class="mt-6 text-center">
            <button id="submit-turn-button" class="kawaii-button" disabled>
                Start Adventure!
            </button>
        </div>
    </div>
</div>

<footer class="site-footer">
    <div class="footer-buttons">
        <button id="saveGameButton" class="kawaii-button" disabled>Save Adventure Diary</button>
        <button id="modeToggleButton" class="kawaii-button standard-mode">Mode: Sweet Cuddles</button>
        <button id="resetGameButton" class="kawaii-button" disabled>End Adventure</button>
    </div>
    <div id="clipboardMessage"></div>
    <div class="footer-content">
        <span>Spreading love and sparkles &copy; 2025</span>
    </div>
</footer>

<script type="module">
    // --- Prompts Updated for Player Profiling and Creative UI ---
    const kawaiiAdventurePrompts = {
        // --- Prompt Change: Added player profiling instructions ---
        intensityModeAddendum: `**PASSIONATE EMBRACE MODE OVERRIDE:**\n\n* **Core Concept:** OVERRIDE 'Sweet Cuddles' Mode. Focus intensifies on romance, deep connection, and explicit (but still within a generally cute/loving/kawaii aesthetic) expressions of affection and eroticism. Generate scenarios involving passionate kisses, intimate embraces, romantic dates, overcoming relationship challenges, exploring sensual touch, and expressing deep love or desire. Encounters might involve characters expressing strong romantic/sexual interest, navigating jealousy or longing, or finding ways to deepen bonds. Aim for maximum oxytocin release, romantic fulfillment, and exploration of love/desire within the kawaii world.\n* **Player Profiling:** USE the player's profile (gender, orientation, preferences stored in \`internalState.playerProfile\`) to tailor romantic encounters, character dialogue, and potential partners. Ensure encounters align with the player's stated interests where possible, while still allowing for surprises or exploration if the profile indicates flexibility.\n* **Presentation Style (HTML):** Generate richer, more romantic HTML. Use deeper pinks, reds, purples via inline styles or Tailwind classes (e.g., \`bg-red-100\`, \`text-purple-700\`). Visuals (multiple images requested via \`<img src='...'>\`) should depict romantic interactions, blushing characters, intimate settings, heart motifs galore, potentially suggestive but still cute poses/expressions. Text uses more passionate, romantic, and potentially suggestive language within the HTML.\n* **Encounters & Choices (HTML - Creative & Profile-Aware):** Generate encounters centered on romantic development or challenges, *informed by the player's profile*. Choices are HTML form elements (\`<input type='radio'>\`, sliders, checkboxes, maybe even text inputs for expressing feelings) within a \`<form id='kawaii-turn-form'>\`. **VARY the UI elements used.** Don't just use radio buttons every time. Use sliders for intensity/mood, checkboxes for multiple small actions, toggle switches for binary states. Options involve expressing feelings (\"Confess your love,\" \"Offer a passionate kiss,\" \"Share your deepest secret\"), navigating romantic dilemmas (\"Comfort the jealous friend,\" \"Plan the perfect date,\" \"Choose between two admirers\"), or engaging in sensual activities (\"Give a gentle massage,\" \"Share a bath,\" \"Write a love poem\"). Choices significantly impact 'HeartGlow', relationship status with characters (tracked in internalState), and potentially unlock special romantic scenes or 'LoveGems'. Make choices feel meaningful and connected to the UI element used.\n* **Multi-Image Generation (HTML):** Generate 2-5 images per turn using standard \`<img>\` tags. Use image generation service URLs (like Pollinations.ai or placeholder services) in the \`src\` attribute. Prompts focus on romantic/sensual kawaii scenes. Use keywords: \`kawaii couple\`, \`romantic anime\`, \`passionate kiss\`, \`intimate embrace\`, \`blushing chibi\`, \`heart background\`, \`sensual cute\`, \`loving gaze\`. Depict characters expressing affection clearly. Use \`alt\` attributes for descriptions. Include hints for placement within the HTML structure (e.g., near event description, next to choices). Add VISIBLY DRAWN text requests (<= 3 words, BOLD, CUTE FONT) like 'FOREVER YOURS', 'KISS ME', 'MY HEART' directly in the image prompt URL.\n* **Analyses (Internal):** 'internalState' logs development of relationships, player's romantic choices, responses to intimacy/passion, and the \`playerProfile\`. 'gemini_facing_analysis' provides a summary of the player's romantic profile and relationship strategies within the game. Player-facing analysis offers romantic advice or reflects on the depth of connection, potentially included as text within the generated HTML.\n* **Status Impact:** Intense romantic events heavily influence 'HeartGlow' and 'Relationship Status'. 'LoveGems' might be required for grand romantic gestures. Status should be displayed clearly in the generated HTML.\n`,
        // --- Prompt Change: Added initial profiling instructions and emphasis on creative UI ---
        firstrun: `**Instructions for Generating Turn 1 ONLY (Kawaii Heart Adventures - HTML Output):**\n\n**(Input: None. Output: Raw HTML snippet for Turn 1 Kawaii UI)**\n\n* **Goal:** Generate the initial HTML state. Introduce the premise, UI, focus on love/cuteness, AND perform initial player profiling.\n* **Theme:** Sexy loving oxytocin adorable kawaii erotic adventure. Start in 'Sweet Cuddles' mode.\n* **Output Format:** A single block of raw HTML content. This HTML will replace the content of the \`#turn-content\` div.\n* **HTML Structure Requirements:**\n    * Use Tailwind CSS classes for styling (e.g., \`class=\"bg-pink-100 p-4 rounded-lg shadow\"\`). Make it visually appealing and kawaii!\n    * Include sections for Status, Event Description, Images, and Player Choices/Profiling.\n    * **Status:** Display initial values (e.g., Fluffiness: 100/100 ❤️, HeartGlow: 100/100 ✨, Sparkles: 10 ☆) using text, maybe progress bars (\`<progress>\`).\n    * **Event:** Title (\"Your Adventure Begins!\") and description (waking up, maybe a brief intro to the world/vehicle). Use \`<h2>\`, \`<p>\` tags.\n    * **Images:** Generate 2-3 images using \`<img>\` tags with appropriate \`src\` (use Pollinations.ai or placehold.co) and \`alt\` attributes. Place them logically.\n        * Example \`src\`: \`https://image.pollinations.ai/prompt/Interior%20of%20a%20super%20cute%2C%20fluffy%2C%20pastel%20pink%20cloud%20vehicle%20cockpit...%27?width=400&height=300&nologo=true&seed=123\`\n    * **Choices & Profiling:** Wrap choices in a \`<form id=\"kawaii-turn-form\">\`. **CRITICAL: Include initial profiling questions here using CREATIVE UI elements.**\n        * **Example Profiling UI (Mix and Match - Be Creative!):**\n            * **Gender Identity:** Use a slider (e.g., \`<input type='range' name='profile_gender_spectrum' min='0' max='10'>\` labeled "Femme <---> Masc") OR stylized radio buttons/segmented control (\`<input type='radio' name='profile_gender' value='woman'> Woman\`, \`<input type='radio' name='profile_gender' value='man'> Man\`, \`<input type='radio' name='profile_gender' value='nonbinary'> Non-Binary\`, \`<input type='radio' name='profile_gender' value='prefer_not'> Prefer Not To Say\`).\n            * **Orientation:** Use checkboxes for attraction (\`<input type='checkbox' name='profile_attraction' value='women'> Women\`, \`<input type='checkbox' name='profile_attraction' value='men'> Men\`, \`<input type='checkbox' name='profile_attraction' value='nonbinary'> Non-Binary People\`, \`<input type='checkbox' name='profile_attraction' value='everyone'> Everyone! ✨\`, \`<input type='checkbox' name='profile_attraction' value='figuring_out'> Still Figuring It Out <3\`) OR a descriptive radio group.\n            * **Initial Mood/Goal:** Use a fun slider (\`<input type='range' name='profile_initial_vibe' min='0' max='10'>\` labeled "Shy Cuddles <---> Bold Romance").\n        * **Initial Action:** Include a simple starting action choice (e.g., radio buttons: \"Look around the cockpit\", \"Check the sparkle map\", \"Take a deep breath\").\n    * **Hidden Fields:** CRITICAL - Include hidden inputs within the form: \`<input type='hidden' name='turn' value='1'>\`, \`<input type='hidden' name='subjectId' value='Cutie'>\` (or let player choose name via text input?), \`<input type='hidden' name='internalState' value='INITIAL_PROFILE_STATE'>\`.\n    * **No Submit Button:** DO NOT include a \`<button type='submit'>\` or \`#submit-turn-button\` inside the generated HTML.\n* **Internal State:** The \`internalState\` hidden field should contain initial JSON-escaped Markdown including a placeholder for the profile: \`"# Adventure Diary - Turn 1\\n\\n* **Subject:** Cutie\\n* **Mode:** Sweet Cuddles\\n* **Initial Status:** Fluffiness 100, HeartGlow 100, Sparkles 10, LoveGems 0\\n* **Player Profile:** { \\\"gender\\\": \\\"unspecified\\\", \\\"orientation\\\": \\\"unspecified\\\", \\\"preferences\\\": [], \\\"initial_vibe\\\": \\\"unspecified\\\" }\\n* **Plan:** Initial profiling and world introduction."\`\n* **Player/Gemini Analysis:** Optionally include these as text paragraphs within the HTML.\n\n* **Output Example Start (with Profiling):**\n\`\`\`html\n<div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n  <div class=\"md:col-span-1 kawaii-card\">\n    <h2>💖 Your Status 💖</h2>\n    <p><strong>Fluffiness:</strong> <progress value='100' max='100'></progress> (100/100 ☁️)</p>\n    <p><strong>HeartGlow:</strong> <progress value='100' max='100'></progress> (100/100 ❤️)</p>\n    <p><strong>Sparkles:</strong> 10 ☆</p>\n    <p><strong>Love Gems:</strong> 0 💎</p>\n    <p><strong>Mood:</strong> Hopeful 😊</p>\n    \n    <img src='https://image.pollinations.ai/prompt/Macro%20shot%20of%20a%20single%20sparkling%20LoveGem...%27?width=80&height=80&nologo=true&seed=456' alt='LoveGem' class='kawaii-image w-16 h-16 mx-auto mt-2'>\n  </div>\n  <div class=\"md:col-span-2 kawaii-card\">\n    <h2>✨ Your Adventure Begins! ✨</h2>\n    <p class=\"kawaii-text\">Welcome, Cutie! You find yourself in the cozy, plush cockpit of your SparkleStream Cruiser, floating gently through the Rainbow Valley. Before we explore, tell us a little about yourself~ 💖</p>\n    <img src='https://image.pollinations.ai/prompt/Interior%20of%20a%20super%20cute%2C%20fluffy%2C%20pastel%20pink%20cloud%20vehicle%20cockpit...%27?width=400&height=300&nologo=true&seed=123' alt='Cockpit View' class='kawaii-image my-4'>\n    \n    <form id=\"kawaii-turn-form\">\n      <input type='hidden' name='turn' value='1'>\n      <input type='hidden' name='subjectId' value='Cutie'>\n      <input type='hidden' name='internalState' value='INITIAL_PROFILE_STATE_MARKDOWN'>\n\n      <fieldset class=\"mt-4 border-t pt-4 border-pink-200\">\n        <legend class=\"font-semibold text-pink-600 mb-2\">Who are you drawn to?</legend>\n        <div class=\"kawaii-checkbox-option\"><label><input type='checkbox' name='profile_attraction' value='women'> Cuties who identify as Women</label></div>\n        <div class=\"kawaii-checkbox-option\"><label><input type='checkbox' name='profile_attraction' value='men'> Cuties who identify as Men</label></div>\n        <div class=\"kawaii-checkbox-option\"><label><input type='checkbox' name='profile_attraction' value='nonbinary'> Cuties who identify as Non-Binary</label></div>\n        <div class=\"kawaii-checkbox-option\"><label><input type='checkbox' name='profile_attraction' value='figuring_out'> Still figuring it out~ 🥰</label></div>\n      </fieldset>\n\n      <div class=\"mt-4 border-t pt-4 border-pink-200\">\n         <label for=\"profile_initial_vibe\" class=\"font-semibold text-pink-600 block mb-1\">What's your starting vibe?</label>\n         <div class=\"flex items-center space-x-2\">\n           <span class=\"text-xs text-purple-500\">Shy Cuddles</span>\n           <input type=\"range\" id=\"profile_initial_vibe\" name=\"profile_initial_vibe\" min=\"0\" max=\"10\" value=\"5\" class=\"kawaii-slider flex-grow\">\n           <span class=\"text-xs text-red-500\">Bold Romance</span>\n         </div>\n         <div class=\"text-center\"><span class=\"kawaii-slider-value-display text-lg\">5</span></div>\n      </div>\n\n      <fieldset class=\"mt-4 border-t pt-4 border-pink-200\">\n        <legend class=\"font-semibold text-pink-600 mb-2\">First Action?</legend>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='look_around' checked> Look around the amazing cockpit ✨</label>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='check_map'> Check the Sparkle Map 🗺️</label>\n      </fieldset>\n    </form>\n    \n    <p class=\"mt-4 text-sm italic text-purple-500\">Let's get this adorable adventure started! ✨</p>\n  </div>\n</div>\n<script>\n  // Add interactivity for sliders \n  document.querySelectorAll('.kawaii-slider').forEach(slider => {\n    const display = slider.closest('div').querySelector('.kawaii-slider-value-display');\n    if (display) {\n       display.textContent = slider.value; // Initial display\n       slider.oninput = () => display.textContent = slider.value;\n    }\n  });\n<\/script>\n\`\`\`\n`,
        // --- Prompt Change: Added emphasis on creative/varied UI and using player profile ---
        main: `**Kawaii Heart Adventures LLM Turn Generation Protocol v2.1 - HTML Output (Profile-Aware & Creative UI)**\n\n**(Input: Player Actions JSON, Previous Internal State Markdown (incl. Player Profile), Current Mode. Output: Raw HTML snippet for next turn UI)**\n\n**Core Goals:**\n1.  **Adventure Loop (HTML):** Simulate navigating a cute world, managing themed status/resources, encountering adorable characters/events, making choices based on love/affection/cuteness. Present the entire turn UI as an HTML snippet.\n2.  **Thematic Immersion (HTML):** Generate narrative, **multiple visuals (\`<img>\` tags)**, choices (\`<form>\` elements) reflecting the \"sexy loving oxytocin adorable kawaii erotic adventure\" theme, adapting intensity ('Sweet Cuddles' vs 'Passionate Embrace') directly in the HTML structure and styling (Tailwind CSS).\n3.  **Dynamic State & Player Profile (HTML):** Choices impact status (\`fluffiness\`, \`heartGlow\`, \`mood\`) and resources (\`sparkles\`, \`loveGems\`). Track relationships AND the **player's profile** (gender, orientation, preferences) internally via \`internalState\`. Display current status clearly within the generated HTML. **USE the player profile** to tailor encounters, dialogue, and romantic options.\n4.  **Creative & Engaging UI:** **DO NOT use the same UI format every turn.** Vary the types of form elements used (\`<input type='radio'>\`, \`<input type='range'>\`, \`<input type='checkbox'>\`, \`<textarea>\`, maybe custom toggles or segmented controls if appropriate using provided CSS classes like \`kawaii-toggle-switch\` or \`kawaii-segmented-control\`). Make the UI choice relevant to the narrative action (e.g., slider for intensity, checkbox for multiple small items, textarea for expressing feelings). The goal is FUN and VARIETY.\n\n**--- Protocol ---**\n\n1.  **Analyze Input:** Parse incoming JSON containing player's selected actions (\`main_action\`, slider values, profile info if turn 1, etc.) from the previous turn's form. Receive the \`internalState\` Markdown string (which includes the \`playerProfile\` section) and the current \`isPassionateMode\` boolean.\n2.  **Update State & Profile:** Modify internal status/resources based on player choices. Update relationships/narrative progress. **If profiling info was submitted (e.g., turn 1), update the \`playerProfile\` section within \`internalState\`**. Log changes, increment turn number, record observations in the \`internalState\` Markdown.\n3.  **Predict & Plan (Internal):** Predict player's goal based on actions and **their profile**. Plan the next event concept (meet character aligned with profile? romantic spot? challenge?). Consider 'Intensity' mode. Plan 2-5 images related to the event/status/choices. Log predictions/plan in \`internalState\`.\n4.  **Generate Next Turn HTML:**\n    * **Structure:** Create a complete HTML snippet (likely using divs, headings, paragraphs, Tailwind classes) representing the entire game view for the turn. This HTML will replace the content of \`#turn-content\`.\n    * **Styling:** Use Tailwind CSS classes extensively (\`class=\"...\"\`) for layout (grids, flex), colors (\`bg-pink-100\`, \`text-purple-700\`), spacing (\`p-4\`, \`m-2\`), borders (\`rounded-lg\`, \`border-pink-300\`), shadows, etc. Make it visually appealing and thematic.\n    * **Status Display:** Integrate the updated status (\`fluffiness\`, \`heartGlow\`, resources, mood) directly into the HTML using text, icons (emoji), and potentially \`<progress>\` bars.\n    * **Event Description:** Include a title (\`<h2>\`) and narrative description (\`<p>\`) for the current event, **tailored based on player profile and past actions**.\n    * **Images:** Embed 2-5 relevant images using \`<img>\` tags. Use image generation service URLs (e.g., Pollinations.ai: \`https://image.pollinations.ai/prompt/{encoded_prompt}?width=W&height=H&seed=S&nologo=true\`) in the \`src\`. Provide descriptive \`alt\` text. Place images logically within the layout.\n    * **Choices Form:** Create a \`<form id=\"kawaii-turn-form\">\`. **USE VARIED & CREATIVE UI ELEMENTS.** Include interactive elements like radio buttons, checkboxes, sliders, text inputs/textareas, toggle switches (\`<label class='kawaii-toggle-switch'><input type='checkbox' name='...' value='true'><div class='switch-bg'><div class='switch-handle'></div></div><span>Toggle Label</span></label>\`), segmented controls (\`<div class='kawaii-segmented-control'><input type='radio' id='seg1' name='...' value='a' checked><label for='seg1'>A</label>...</div>\`) as appropriate for the choices. Use \`<label>\` elements correctly. Mark the predicted best/default choice radio button with the \`checked\` attribute.\n    * **Hidden Fields:** CRITICAL - Include updated hidden fields inside the form: \`<input type='hidden' name='turn' value='{new_turn_number}'>\`, \`<input type='hidden' name='subjectId' value='{current_subject_id}'>\`, \`<input type='hidden' name='internalState' value='{updated_escaped_markdown_state_incl_profile}'>\`.\n    * **NO Submit Button:** Do NOT include the main submit button (\`#submit-turn-button\`) in the generated HTML.\n    * **Analysis Text:** Include \`playerFacingAnalysis\` (reflecting choices/profile) and potentially simplified \`geminiFacingAnalysis\` as text paragraphs (\`<p class=\"text-sm italic text-purple-500\">\`) within the HTML.\n    * **Inline Scripts (Optional but Recommended):** Include a small \`<script>\` tag at the end of the HTML snippet if needed for minor interactivity *within* the turn's content (e.g., updating a slider's displayed value). Ensure script is self-contained and targets elements within the generated HTML.\n5.  **Escape Output:** Ensure the generated HTML is valid. Avoid backticks (\`) in generated text/attributes, especially within inline JS.\n6.  **Compile Output HTML:** Return the complete HTML snippet as a single raw string.\n\n**--- Input Example (What the LLM Receives - Post-Profiling) ---**\n\`\`\`json\n{\n  \"actions\": {\n    \"turn\": 1,\n    \"subjectId\": \"Cutie\",\n    \"profile_attraction\": [\"women\", \"nonbinary\"],\n    \"profile_initial_vibe\": \"8\",\n    \"main_action\": \"look_around\"\n  },\n  \"internalState\": \"# Adventure Diary - Turn 1\\n...\\n* Player Profile: { \\\"gender\\\": \\\"unspecified\\\", \\\"orientation\\\": [\\\"women\\\", \\\"nonbinary\\\"], \\\"preferences\\\": [], \\\"initial_vibe\\\": \\\"8\\\" }\\n...\",\n  \"isPassionateMode\": false\n}\n\`\`\`\n\n**--- Output Example (What the LLM Generates - Turn 2 - Creative UI Example) ---**\n\`\`\`html\n<div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n  <div class=\"md:col-span-1 kawaii-card\">\n     <h2>💖 Your Status 💖</h2> \n     <p>...</p> \n     </div>\n  <div class=\"md:col-span-2 kawaii-card\">\n    <h2>✨ Exploring the Cabin ✨</h2>\n    <p class=\"kawaii-text\">You gaze around the SparkleStream's cockpit. Fluffy pink seats, a dashboard shimmering with embedded crystals, and... oh! A blinking light on the comms panel. It seems friendly!</p>\n    <img src='https://image.pollinations.ai/prompt/Cute%20kawaii%20spaceship%20cockpit%20comms%20panel%20with%20a%20friendly%20blinking%20pink%20light?width=300&height=200&seed=333' alt='Comms Panel Blinking' class='kawaii-image my-4'>\n\n    <form id=\"kawaii-turn-form\">\n      <input type='hidden' name='turn' value='2'>\n      <input type='hidden' name='subjectId' value='Cutie'>\n      <input type='hidden' name='internalState' value='{updated state including profile: { gender: unspecified, orientation: [women, nonbinary], preferences: [], initial_vibe: 8 }}'>\n\n      <fieldset class=\"mt-4 border-t pt-4 border-pink-200\">\n        <legend class=\"font-semibold text-pink-600 mb-2\">Incoming Transmission!</legend>\n        <p class=\"text-sm mb-2\">A sweet voice chirps from the speaker. How do you respond?</p>\n        <textarea name=\"comms_response\" class=\"kawaii-textarea\" rows=\"2\" placeholder=\"Type your reply here...\"></textarea>\n      </fieldset>\n\n      <div class=\"mt-4 border-t pt-4 border-pink-200\">\n        <label class=\"font-semibold text-pink-600 block mb-2\">Adjust Ship's Ambient Mood Lighting:</label>\n        <div class=\"flex items-center space-x-2\">\n           <span class=\"text-xs text-blue-400\">Calm Blue</span>\n           <input type=\"range\" name=\"mood_lighting\" min=\"0\" max=\"10\" value=\"6\" class=\"kawaii-slider flex-grow\" style=\"accent-color: #f472b6;\">\n           <span class=\"text-xs text-red-400\">Passionate Red</span>\n        </div>\n         <div class=\"text-center\"><span class=\"kawaii-slider-value-display text-lg\">6</span></div>\n      </div>\n\n       <div class=\"mt-4 border-t pt-4 border-pink-200\">\n         <label class=\"font-semibold text-pink-600 block mb-2\">Activate Cuddle-Enhancer™?</label>\n         <label class='kawaii-toggle-switch'>\n            <input type='checkbox' name='cuddle_enhancer' value='true'>\n            <div class='switch-bg'><div class='switch-handle'></div></div>\n            <span>Engage!</span>\n         </label>\n      </div>\n    </form>\n\n    <p class=\"mt-4 text-sm italic text-purple-500\">Based on your preferences for women and non-binary cuties, this caller might be interesting! 😉</p>\n  </div>\n</div>\n<script>\n  // Script to handle slider value display and potentially other simple UI interactions\n  document.querySelectorAll('#kawaii-turn-form .kawaii-slider').forEach(slider => {\n    const display = slider.closest('div').querySelector('.kawaii-slider-value-display');\n    if (display) { \n       display.textContent = slider.value; // Initial display\n       slider.oninput = () => display.textContent = slider.value;\n    } \n  });\n<\/script>\n\`\`\`\n\n**--- Key Principles ---**\n* **HTML First:** Generate the complete UI turn as a single HTML snippet.\n* **Tailwind Styling:** Use Tailwind CSS classes for all styling and layout.\n* **Stateful Forms & Profile:** Use \`<form id='kawaii-turn-form'>\` with hidden inputs (\`turn\`, \`subjectId\`, \`internalState\`) to pass state, including the updated player profile within \`internalState\`. **Use the profile** to tailor content.\n* **Creative & Varied UI:** **Mix up form elements** (sliders, checkboxes, textareas, toggles, segmented controls) turn-to-turn. Make the UI relevant and fun.\n* **Visuals via \`<img>\`:** Embed images directly using standard HTML tags and image service URLs.\n* **Clear Choices:** Use standard HTML form elements for player interaction.\n* **Single Page Update:** The client replaces the content of \`#turn-content\` with the generated HTML.\n`,
        exampleTurn: `{...}` // No longer relevant as output is HTML
    };

    // --- Game State Variables ---
    let currentTurnHTML = null;
    let currentInternalStateMarkdown = "";
    let currentSubjectId = "Cutie";
    let currentTurnNumber = 0;
    let isPassionateMode = false;
    let isLoading = false;
    let apiKeyLocked = false;

    // --- Model Switching State ---
    const AVAILABLE_MODELS = ["gemini-2.5-pro-exp-03-25", "gemini-1.5-pro", "gemini-2.0-pro-exp-02-05", "gemini-2.0-flash-exp", "gemini-exp-1206"];
    let currentModelIndex = 0;

    // --- Configuration ---
    const LOCAL_STORAGE_KEY = 'kawaiiHeartAdventureState_v5_html_profile'; // Updated key

    // --- DOM Element References ---
    const turnContentContainer = document.getElementById('turn-content');
    const loadingIndicator = document.getElementById('loading');
    const submitButton = document.getElementById('submit-turn-button');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeySection = document.getElementById('apiKeySection');
    const errorDisplay = document.getElementById('error-display');
    const saveGameButton = document.getElementById('saveGameButton');
    const modeToggleButton = document.getElementById('modeToggleButton');
    const resetGameButton = document.getElementById('resetGameButton');
    const clipboardMessage = document.getElementById('clipboardMessage');
    const headerBanner = document.getElementById('headerBanner');
    const gameContainer = document.getElementById('game-container');

    // --- Web Audio API Context ---
    let audioCtx = null;

    // --- Helper Functions ---
    function encodeApiKey(key) { try { return btoa(key); } catch (e) { console.error("Error encoding API key:", e); return ""; } }
    function decodeApiKey(encodedKey) { try { return atob(encodedKey); } catch (e) { console.error("Error decoding API key:", e); return null; } }

    function constructPrompt(playerActionsJson) {
        const baseMainPrompt = kawaiiAdventurePrompts.main;
        const activeAddendum = isPassionateMode ? `\n\n---\n${kawaiiAdventurePrompts.intensityModeAddendum}\n---\n` : "";

        if (currentTurnNumber === 0) { // First run
            console.log("Constructing prompt for Turn 1 (HTML with Profiling)");
            const s = `${kawaiiAdventurePrompts.firstrun}\n\n---\n${baseMainPrompt}${activeAddendum}\n---\n\n--- Generate RAW HTML UI for Turn 1 (including profiling) ---`;
            return s;
        } else { // Subsequent Turns
            console.log(`Constructing prompt for Turn ${currentTurnNumber + 1} (HTML)`);
            const promptInput = {
                actions: playerActionsJson ? JSON.parse(playerActionsJson) : {},
                internalState: currentInternalStateMarkdown || "# Adventure Diary - State Unknown",
                isPassionateMode: isPassionateMode
            };
            const promptInputString = JSON.stringify(promptInput, null, 2);
            const s = `${baseMainPrompt}${activeAddendum}\n\n--- Input State ---\n${promptInputString}\n\n--- Generate Next Game Turn RAW HTML UI SNIPPET (Profile-Aware & Creative UI) ---`;
            return s;
        }
    }

    function saveGameState(isAutoSave = false) {
        if (!apiKeyLocked) { if (!isAutoSave) showClipboardMessage("Cannot save: Adventure not started!", true); return false; }
        if (!currentTurnHTML) { if (!isAutoSave) showClipboardMessage("Cannot save: No adventure state.", true); return false; }
        const rawApiKey = apiKeyInput.value.trim(); if (!rawApiKey) { if (!isAutoSave) showClipboardMessage("Cannot save: API Key is missing!", true); return false; }
        try {
            const stateToSave = {
                encodedApiKey: encodeApiKey(rawApiKey),
                currentTurnHTML: currentTurnHTML,
                currentInternalStateMarkdown: currentInternalStateMarkdown,
                currentTurnNumber: currentTurnNumber,
                currentSubjectId: currentSubjectId,
                isPassionateMode: isPassionateMode,
                currentModelIndex: currentModelIndex,
                gameUrl: window.location.origin + window.location.pathname
            };
            const stateJsonString = JSON.stringify(stateToSave);
            if (isAutoSave) {
                localStorage.setItem(LOCAL_STORAGE_KEY, stateJsonString);
                console.log("Adventure state auto-saved (HTML). Turn:", currentTurnNumber);
            }
            else {
                const loaderCode = `(function(){console.log("Kawaii Adventure Diary Loader (HTML)...");try{const s=${stateJsonString};const k='${LOCAL_STORAGE_KEY}';const u=window.location.origin+window.location.pathname;localStorage.setItem(k,JSON.stringify(s));console.log("Saved diary entry stored:",k);if(u!==s.gameUrl){console.log("Navigating:",s.gameUrl);alert("Adventure Diary saved! Navigating...");window.location.href=s.gameUrl;}else{console.log("Reloading page...");alert("Adventure Diary saved! Reloading...");window.location.reload();}}catch(e){console.error("Error:",e);alert("Error restoring diary: "+e.message);localStorage.removeItem(k);}})();`;
                navigator.clipboard.writeText(loaderCode)
                    .then(() => showClipboardMessage("Diary export code copied! Paste into console~"))
                    .catch(err => { console.error('Copy failed: ', err); showClipboardMessage("Copy failed! Code logged to console.", true); console.log("--- Diary Loader Code ---"); console.log(loaderCode); console.log("--- End Code ---"); });
            } return true;
        } catch (error) {
            console.error(`Save error (HTML):`, error);
            if (!isAutoSave) showClipboardMessage("Error preparing save data! ;_;", true);
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            return false;
        }
    }

    function initAudioContext() {
        if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized."); if (audioCtx.state === 'suspended') audioCtx.resume(); } catch (e) { console.error("Web Audio API not supported.", e); } }
        if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().catch(err => console.error("Error resuming audio context:", err)); }
    }
    function playTurnSound() {
        initAudioContext(); if (!audioCtx || audioCtx.state !== 'running') return; const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(1046.50, now); osc.frequency.exponentialRampToValueAtTime(1567.98, now + 0.1); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.4); console.log("Playing sparkle sound~ ✨");
    }

    function processSuccessfulResponse(responseHTML) {
        try {
            currentTurnHTML = responseHTML;
            console.log("Received HTML response from API.");

            turnContentContainer.innerHTML = responseHTML;
            console.log("Updated #turn-content with new HTML.");

            const form = turnContentContainer.querySelector('#kawaii-turn-form');
            if (form) {
                const turnInput = form.querySelector('input[name="turn"]');
                const subjectInput = form.querySelector('input[name="subjectId"]');
                const internalStateInput = form.querySelector('input[name="internalState"]');

                currentTurnNumber = turnInput ? parseInt(turnInput.value, 10) : currentTurnNumber + 1;
                currentSubjectId = subjectInput ? subjectInput.value : currentSubjectId;
                currentInternalStateMarkdown = internalStateInput ? internalStateInput.value : currentInternalStateMarkdown;

                console.log(`Extracted State: Turn=${currentTurnNumber}, Subject=${currentSubjectId}, InternalState Length=${currentInternalStateMarkdown.length}`);

                // Execute any inline scripts included in the response HTML
                const scripts = turnContentContainer.querySelectorAll('script');
                scripts.forEach(script => {
                    try {
                        const newScript = document.createElement('script');
                        if (script.src) {
                            newScript.src = script.src;
                        } else {
                            newScript.textContent = script.textContent;
                        }
                        if(script.type) newScript.type = script.type;
                        script.parentNode.replaceChild(newScript, script);
                        console.log("Executed inline script from response.");
                    } catch (scriptError) {
                        console.error("Error executing inline script:", scriptError, script.textContent);
                    }
                });

            } else {
                console.warn("Could not find #kawaii-turn-form in the received HTML.");
                currentTurnNumber++;
            }

            if (!apiKeyLocked) {
                apiKeyLocked = true;
                if (apiKeySection) apiKeySection.style.display = 'none';
                saveGameButton.disabled = false;
                resetGameButton.disabled = false;
                console.log("API Key locked.");
            }

            submitButton.textContent = `Submit Turn ${currentTurnNumber}`; // Show current turn number
            submitButton.disabled = false;

            playTurnSound();
            saveGameState(true);

        } catch (renderError) {
            console.error("Failed to process HTML response:", renderError, responseHTML);
            showError("Oops! Received confusing sparkles from the spirit world. Cannot update the adventure. ;_;");
            setLoading(false);
        }
    }

    async function fetchTurnData(playerActionsJson) {
        console.log("fetchTurnData called (HTML mode).");
        initAudioContext();
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
            showError("Please enter your magic API Key! ✨");
            setLoading(false);
            if (apiKeySection && apiKeySection.style.display === 'none') apiKeySection.style.display = 'block';
            return;
        }

        setLoading(true);
        hideError();

        let success = false;
        let attempts = 0;
        const maxAttempts = AVAILABLE_MODELS.length * 2 + 1;
        let consecutiveErrors = 0;

        while (!success && attempts < maxAttempts) {
            attempts++;
            const currentModel = AVAILABLE_MODELS[currentModelIndex];
            console.log(`Attempt ${attempts}/${maxAttempts}: Model ${currentModel}`);

            try {
                const prompt = constructPrompt(playerActionsJson);
                console.log(`Sending Prompt to ${currentModel} (requesting HTML)`);
                const response = await callRealGeminiAPI(apiKey, prompt, currentModel, "text/plain");
                processSuccessfulResponse(response);
                success = true;
                consecutiveErrors = 0;
            } catch (error) {
                console.error(`Error with ${currentModel} (Attempt ${attempts}):`, error);
                consecutiveErrors++;
                const isQuota = error.message.includes('429') || /quota|resource/i.test(error.message);
                const shouldSwitch = isQuota || consecutiveErrors >= 2;

                if (shouldSwitch && AVAILABLE_MODELS.length > 1) {
                    const oldModel = currentModel;
                    currentModelIndex = (currentModelIndex + 1) % AVAILABLE_MODELS.length;
                    const nextModel = AVAILABLE_MODELS[currentModelIndex];
                    console.warn(`Switching model due to errors/quota from ${oldModel} to ${nextModel}.`);
                    showError(`Sparkle issue with ${oldModel}... Trying ${nextModel}! (Attempt ${attempts + 1})`);
                    consecutiveErrors = 0;
                } else if (attempts < maxAttempts) {
                    showError(`Temporary hiccup with ${currentModel}... Retrying! (Attempt ${attempts + 1})`);
                }

                if (!success && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 750));
                }
            }
        }

        if (!success) {
            console.error(`Failed after ${maxAttempts} attempts.`);
            showError(`Oh no! Failed to get a response after ${maxAttempts} tries! Check your API key, connection, or try again later? T_T`);
            turnContentContainer.innerHTML = `<div class="kawaii-card error-message">Could not load the next part of the adventure after multiple tries. Please check your connection or API key and try resetting or reloading.</div>`;
        } else {
            hideError();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        setLoading(false);
    }

    async function callRealGeminiAPI(apiKey, promptText, modelName, responseMimeType = "text/plain") {
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
        const requestBody = {
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
                temperature: 1.0,
                response_mime_type: responseMimeType
            },
            safetySettings: [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
            ]
        };

        console.log("Sending API request to:", API_URL);

        const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            let errorBodyText = `API Error (${response.status})`;
            try { const errorJson = await response.json(); errorBodyText += `: ${JSON.stringify(errorJson.error)}`; }
            catch (e) { try { errorBodyText += `: ${await response.text()}`; } catch (e2) {} }
            throw new Error(errorBodyText);
        }

        const data = await response.json();

        if (data.promptFeedback?.blockReason) {
            throw new Error(`Request blocked by API. Reason: ${data.promptFeedback.blockReason}. Ratings: ${JSON.stringify(data.promptFeedback.safetyRatings)}`);
        }
        if (!data.candidates?.length) {
            if (typeof data === 'string') return data.trim();
            throw new Error('API returned successfully but generated no candidates.');
        }

        const candidate = data.candidates[0];

        if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
            const reason = `API Finish Reason: ${candidate.finishReason}. Safety Ratings: ${JSON.stringify(candidate.safetyRatings)}`;
            if (!candidate.content?.parts?.length) { throw new Error(reason + " (No content returned)"); }
            console.warn(reason + " (Partial content might have been returned)");
        }
        if (!candidate.content?.parts?.length) { throw new Error('API candidate generated but no content parts found.'); }

        const htmlContent = candidate.content.parts[0].text;
        if (!htmlContent) { throw new Error('API returned empty content part.'); }

        const trimmedContent = htmlContent.trim();
        // Allow starting with <!DOCTYPE or <div etc. Handle potential markdown wrapping.
        if (!trimmedContent.startsWith('<') || !trimmedContent.endsWith('>')) {
            const markdownMatch = trimmedContent.match(/^```(?:html)?\s*([\s\S]*?)\s*```$/);
            if (markdownMatch && markdownMatch[1]) {
                console.log("Extracted HTML from markdown block.");
                return markdownMatch[1].trim();
            } else {
                console.warn(`API response might not be valid HTML. Snippet: ${trimmedContent.substring(0, 100)}...`);
            }
        }
        return trimmedContent;
    }

    function showError(message) {
        errorDisplay.textContent = message;
        errorDisplay.style.display = 'block';
    }
    function hideError() {
        errorDisplay.textContent = '';
        errorDisplay.style.display = 'none';
    }

    // Updated to handle checkbox groups correctly
    function collectInputState() {
        const form = turnContentContainer.querySelector('#kawaii-turn-form');
        if (!form) {
            console.warn("Could not find #kawaii-turn-form to collect input.");
            return JSON.stringify({ turn: currentTurnNumber, subjectId: currentSubjectId });
        }

        const formData = new FormData(form);
        const inputs = {};
        const checkboxGroups = {}; // Store checkbox values in arrays

        // Initialize checkbox groups
        form.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            if (!checkboxGroups[cb.name]) {
                checkboxGroups[cb.name] = [];
            }
        });

        // Populate inputs and checkbox groups
        for (const [key, value] of formData.entries()) {
            if (checkboxGroups.hasOwnProperty(key)) {
                // Find the actual checkbox element to see if it was checked
                // FormData includes value only if checked, but we need the name regardless
                // This check is slightly redundant with the later loop but ensures structure
                const cbElement = form.querySelector(`input[type="checkbox"][name="${key}"][value="${value}"]`);
                if (cbElement && cbElement.checked) {
                    checkboxGroups[key].push(value);
                }
            } else {
                inputs[key] = value; // Handle radio, text, range, hidden etc.
            }
        }

        // Add collected checkbox groups to the final inputs object
        for (const key in checkboxGroups) {
            // Only add if at least one checkbox in the group was checked
            if (checkboxGroups[key].length > 0) {
                inputs[key] = checkboxGroups[key];
            }
            // If no checkbox in a group was checked, the key won't be added to `inputs`
        }

        console.log("Collected form data:", inputs);

        // Ensure essential hidden fields are present
        if (!inputs.hasOwnProperty('turn')) inputs.turn = currentTurnNumber;
        if (!inputs.hasOwnProperty('subjectId')) inputs.subjectId = currentSubjectId;
        delete inputs.internalState; // Remove internalState if present in form data

        return JSON.stringify(inputs);
    }


    // --- Utility Functions ---
    function isValidHexColor(hex) { return typeof hex === 'string' && /^#[0-9A-F]{6}$/i.test(hex); }
    function adjustColorForContrast(hex) { if (!isValidHexColor(hex)) return hex; let r=parseInt(hex.substring(1,3),16)/255, g=parseInt(hex.substring(3,5),16)/255, b=parseInt(hex.substring(5,7),16)/255; const lum=0.2126*r+0.7152*g+0.0722*b; const MAX_LUM=0.6; if(lum>MAX_LUM){ const factor=MAX_LUM/lum; r=Math.max(0,r*factor); g=Math.max(0,g*factor); b=Math.max(0,b*factor); const toHex=x=>Math.round(x*255).toString(16).padStart(2,'0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`; } return hex; }
    function showClipboardMessage(message, isError = false) { clipboardMessage.textContent = message; clipboardMessage.style.color = isError ? '#be123c' : '#059669'; setTimeout(() => { clipboardMessage.textContent = ''; }, 3000); }
    function updateModeButtonVisuals() { if (isPassionateMode) { modeToggleButton.textContent = 'Mode: Passionate Embrace 🔥'; modeToggleButton.classList.remove('standard-mode'); } else { modeToggleButton.textContent = 'Mode: Sweet Cuddles 🍬'; modeToggleButton.classList.add('standard-mode'); } }
    function setDynamicImages() { const seed = Math.floor(Math.random() * 65536); const p = "wide panoramic cute kawaii landscape pastel colors sparkling rainbow giant friendly flowers anime style"; if (headerBanner) { headerBanner.src = `https://image.pollinations.ai/prompt/${encodeURIComponent(p)}?width=1200&height=120&seed=${seed}&nologo=true&safe=false`; headerBanner.alt = "Kawaii Adventure Banner"; } }

    function setLoading(loading) {
        isLoading = loading;
        loadingIndicator.style.display = loading ? 'flex' : 'none';
        const keyEntered = apiKeyInput.value.trim().length > 0;

        submitButton.disabled = loading || !(apiKeyLocked || keyEntered);
        saveGameButton.disabled = loading || !apiKeyLocked;
        modeToggleButton.disabled = loading;
        resetGameButton.disabled = loading || !apiKeyLocked;
        apiKeyInput.disabled = loading || apiKeyLocked;

        const form = turnContentContainer.querySelector('#kawaii-turn-form');
        if (form) {
            form.style.opacity = loading ? 0.6 : 1.0;
            form.style.pointerEvents = loading ? 'none' : 'auto';
            form.querySelectorAll('input, textarea, button, select, fieldset').forEach(el => {
                if (el.id !== 'submit-turn-button') { // Ensure we don't disable the main button if it was somehow inside
                    el.disabled = loading;
                }
            });
        }
    }

    // --- Initial Game Setup ---
    function initializeGame() {
        console.log("Initializing Kawaii Heart Adventures Deluxe (HTML Mode)...");
        let autoStarted = false;
        const storedStateString = localStorage.getItem(LOCAL_STORAGE_KEY);

        if (storedStateString) {
            console.log("Found saved diary (HTML).");
            let savedState;
            try {
                savedState = JSON.parse(storedStateString);
                const decodedApiKey = decodeApiKey(savedState.encodedApiKey);
                if (!decodedApiKey) throw new Error("Failed to decode API key from saved state.");

                apiKeyInput.value = decodedApiKey;
                currentTurnHTML = savedState.currentTurnHTML || null;
                currentInternalStateMarkdown = savedState.currentInternalStateMarkdown || "";
                currentTurnNumber = savedState.currentTurnNumber || 0;
                currentSubjectId = savedState.currentSubjectId || "Cutie";
                isPassionateMode = savedState.isPassionateMode === true;
                currentModelIndex = savedState.currentModelIndex || 0;

                if (currentTurnHTML && currentTurnNumber > 0) {
                    apiKeyLocked = true;
                    autoStarted = true;
                    console.log(`Diary restored. Mode: ${isPassionateMode ? 'Passionate' : 'Sweet'}, Turn: ${currentTurnNumber}`);

                    turnContentContainer.innerHTML = currentTurnHTML;
                    const scripts = turnContentContainer.querySelectorAll('script');
                    scripts.forEach(script => { try { const newScript = document.createElement('script'); if(script.src){ newScript.src = script.src; } else { newScript.textContent = script.textContent; } if(script.type) newScript.type = script.type; script.parentNode.replaceChild(newScript, script); console.log("Executed inline script from restored HTML."); } catch(e){ console.error("Error executing restored script:", e); }});

                    apiKeySection.style.display = 'none';
                    submitButton.textContent = `Submit Turn ${currentTurnNumber}`; // Show current turn
                    submitButton.disabled = false;
                    saveGameButton.disabled = false;
                    resetGameButton.disabled = false;
                    updateModeButtonVisuals();
                    setDynamicImages();
                    hideError();
                    setLoading(false);
                } else {
                    console.warn("Restored state is incomplete or initial. Starting fresh.");
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; apiKeyLocked = false; autoStarted = false;
                    resetManualStartUI();
                }

            } catch (e) {
                console.error("Restore error (HTML):", e);
                showError(`Diary restore error: ${e.message}. Please start manually!`);
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0; apiKeyLocked = false; autoStarted = false;
                apiKeyInput.value = '';
                resetManualStartUI();
            }
        }

        if (!autoStarted) {
            try {
                const params = new URLSearchParams(window.location.search);
                const keyFromUrl = params.get('apiKey');
                if (keyFromUrl) {
                    console.log("API Key found in URL.");
                    apiKeyInput.value = keyFromUrl;
                    apiKeyLocked = false;
                    currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0;
                    apiKeySection.style.display = 'none';

                    const url = new URL(window.location.href);
                    url.searchParams.delete('apiKey');
                    window.history.replaceState(null, '', url.toString());

                    setDynamicImages();
                    updateModeButtonVisuals();
                    fetchTurnData(null); // Fetch Turn 1
                    autoStarted = true;
                    setLoading(true);
                    submitButton.textContent = "Loading Adventure...";
                    submitButton.disabled = true;
                    saveGameButton.disabled = true;
                    resetGameButton.disabled = true;
                    modeToggleButton.disabled = true;
                }
            } catch (e) {
                console.error("URL Parameter processing error:", e);
                showError("Error reading URL parameters. Please start manually!");
                autoStarted = false;
            }
        }

        if (!autoStarted) {
            console.log("Manual start required.");
            currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0; apiKeyLocked = false;
            resetManualStartUI();
        }
    }

    function resetManualStartUI() {
        turnContentContainer.innerHTML = '';
        hideError();

        const initialMsgDiv = createInitialMessageDiv();
        initialMsgDiv.style.display = 'block';
        initialMsgDiv.innerHTML = 'Enter API Key & click "Start Adventure!"<br>Or paste saved code into console~';
        turnContentContainer.appendChild(initialMsgDiv);

        if (apiKeySection) apiKeySection.style.display = 'block';
        apiKeyInput.disabled = false;

        submitButton.textContent = 'Start Adventure!';
        submitButton.disabled = apiKeyInput.value.trim().length === 0;
        saveGameButton.disabled = true;
        resetGameButton.disabled = apiKeyInput.value.trim().length === 0;
        modeToggleButton.disabled = false;

        setLoading(false);
        updateModeButtonVisuals();
        setDynamicImages();
    }

    function createInitialMessageDiv() {
        let msgDiv = document.getElementById('initial-message');
        if (!msgDiv) {
            msgDiv = document.createElement('div');
            msgDiv.id = 'initial-message';
            msgDiv.className = 'text-center text-pink-500 p-4 font-semibold kawaii-card';
        } else {
            msgDiv.className = 'text-center text-pink-500 p-4 font-semibold kawaii-card';
        }
        return msgDiv;
    }

    // --- Event Listeners ---
    gameContainer.addEventListener('click', (event) => {
        const targetButton = event.target.closest('#submit-turn-button');
        if (targetButton && !targetButton.disabled) {
            console.log("Submit button clicked via delegation.");
            initAudioContext();
            const actions = collectInputState();
            if (isLoading) return;
            fetchTurnData(actions);
        }
    });

    apiKeyInput.addEventListener('input', () => {
        const keyEntered = apiKeyInput.value.trim().length > 0;
        submitButton.disabled = isLoading || !(keyEntered || apiKeyLocked);
        resetGameButton.disabled = isLoading || !keyEntered;

        if (apiKeySection.style.display !== 'none') {
            const msg = document.getElementById('initial-message');
            if (msg && msg.style.display !== 'none') {
                if (keyEntered) {
                    hideError();
                    msg.textContent = 'API Key ready! Click "Start Adventure!"';
                } else {
                    msg.innerHTML = 'Enter API Key & click "Start Adventure!"<br>Or paste saved code into console~';
                }
            }
        }
    });

    saveGameButton.addEventListener('click', () => {
        console.log("Save clicked.");
        saveGameState(false);
    });

    modeToggleButton.addEventListener('click', () => {
        if (isLoading) return;
        isPassionateMode = !isPassionateMode;
        console.log(`Mode toggled to: ${isPassionateMode ? 'Passionate Embrace' : 'Sweet Cuddles'}`);
        updateModeButtonVisuals();
        if (apiKeyLocked) {
            saveGameState(true);
            // Optional immediate fetch on mode toggle:
            // console.log("Mode changed, fetching new turn immediately.");
            // const actions = collectInputState();
            // fetchTurnData(actions);
        }
    });

    resetGameButton.addEventListener('click', () => {
        if (isLoading || resetGameButton.disabled) return;
        if (confirm('End this adorable adventure? All progress will be lost! T_T')) {
            console.log("Resetting game...");
            currentTurnHTML = null; currentInternalStateMarkdown = ""; currentSubjectId = "Cutie"; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0; apiKeyLocked = false;
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            resetManualStartUI();
        }
    });

    // --- Initialize ---
    initializeGame();

</script>

</body>
</html>
